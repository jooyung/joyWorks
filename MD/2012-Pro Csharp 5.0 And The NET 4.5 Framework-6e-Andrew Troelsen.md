# Introduction
## Part I: Introducing C# and the .NET Platform
## Part II: Core C# Programming
## Part III: Object-Oriented Programming with C#
## Part IV: Advanced C# Programming
## Part V: Programming with .NET Assemblies
## Part VI: Introducing the .NET Base Class Libraries
## Part VII: Windows Presentation Foundation
## Part VIII: ASP.NET Web Forms
___
# 1. The Philosophy of .NET
[T] COM: Component Object Model
## An Initial Look at the .NET Platform
### Some Key Benefits of the .NET Platform
[W] To set the stage, here is a quick `rundown` of some core features provided courtesy of .NET:

Existing COM binaries can _**commingle**_ (i.e., interop) with newer .NET software and vice versa.
## Introducing the Building Blocks of the .NET Platform (the CLR, CTS, and CLS)
From a programmer's point of view, .NET can be understood as a runtime environment and a comprehensive base class library.

[T] CLR: Common Language Runtime

[T] CTS: Common Type System

[T] CLS: Common Language Specification

### The Role of the Base Class Libraries
ASP.NET: web sites

WCF (Windows Communication Foundation): networked services

WPF (Windows Presentation Foundation): desktop GUI applications

### What C# Brings to the Table
[T] LINQ: Language Integrated Query

Due to the fact that C# is a hybrid of numerous languages, the result is a product that is as syntactically clean-if not cleaner-as Java, is about as simple as VB, and provides just about as much power and flexibility as C++.

[W] Working with generic types is much more intuitive, given that you can easily map generic data to and from System.Object collections via `covariance` and `contravariance`.
### Managed vs. Unmanaged Code
The binary unit that contains the managed code is termed an _**assembly**_.
## Additional .NET-Aware Programming Languages
### Life in a Multilanguage World
[W] First, we programmers are a very particular `lot` when it comes to our choice of programming language.

[W]If your language of choice happens to be C# but you are placed at a client side that has committed to Visual Basic, you are still able to leverage the functionality of the .NET Framework, and you should be able to understand the overall structure of the code base `with minimal fuss and bother`.
## An Overview of .NET Assemblies
[T] IL: Intermediate Language
[T] assembly: When a *.dll or *.exe has been created using a .NET-aware compiler, the binary blob is termed an _**assembly**_.

As mentioned, an assembly contains CIL code, which is conceptually similar to **Java bytecode** in that it is not compiled to platform-specific instructions until absolutely necessary.

`
c:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe
`

`
"c:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\ildasm.exe" Calc.exe
`

`
c:\Windows\Microsoft.NET\Framework64\v4.0.30319\vbc.exe
`

.NET **metadata** is always present within an assembly, and is automatically generated by a .NET-aware language compiler.

[T] manifest: Finally, in addition to CIL and type metadata, assemblies themselves are also described using metadata, which is officially termed a **manifest**. The manifest contains informatin about the current version of the assembly, culture information (used for localizing string and image resources), and a list of all externally referenced assemblies that are required for proper execution.
### The Role of the Common Intermediate Language
[W] Don't worry if you are unable to `make heads or tails of` the resulting CIL for this method.
#### Benefits of CIL
#### Compiling CIL to Platform-Specific Instructions
JIT: The entity that compiles CIL code into meaningful CPU instructions is a JIT compiler, which sometimes goes by the friendly name of _**Jitter**_.

`
"c:\Windows\Microsoft.NET\Framework64\v4.0.30319\ngen.exe" install Calc.exe
`
### The Role of .NET Type Metadata
### The Role of the Assembly Manifest
## Understanding the Common Type System
[T] type: In the world of .NET, _**type**_ is simply a general term used to refer to a member from the set {class, interface, structure, enumeration, delegate}.
### CTS Class Types
### CTS Interface Types
### CTS Structure Types
### CTS Enumeration Types
### CTS Delegate Types
### CTS Type Members
Formerly speaking, a type member is constrained by the set {constructor, finalizer, static constructor, nested type, operator, method, property, indexer, field, read-only field, constant, event}.
### Intrinsic CTS Data Types
Although a given language typically has a unique keyword used to declare a fundamental data type, all.NET language keywords ultimately resolve to the same CTS type defined in an assembly named _**mscorlib.dll**_.
## Understanding the Common Language Specification
Given these possible variations, it would be ideal to have a baseline to which all .NET-aware languages are expected to conform.

In many ways, the CLS can be viewed as a subset of the full functinality defined by the CTS.

[W] crème de la crème  (krĕm′ də lä krĕm′):

1. Something superlative.
1. People of the highest social level.

The `crème de la crème` of the CLS is Rule 1.
>Rule 1: CLS rules apply only to those parts of a type that are exposed outside the defining assembly.

[W] Luckily, you don't have to `commit these rules to memory` to be a proficient .NET developer.

[W] Again, `by and large`, an intimate understanding of the CTS and CLS specifications is typically only of interest to tool/compiler builders.
### Ensuring CLS Compliance
## Understanding the Common Language Runtime
[W] In addition to the CTS and CLS specifications, the final `TLA`(three-letter abbreviation) to contend with at the moment is the CLR.

Programatically speaking, the term _**runtime**_ can be understood as a collection of services that are required to execute a given compiled unit of code.

The crux of the CLR is physically represented by a library named _**mscoree.dll**_ (a.k.a. the Common Object Runtime Excution Engine).

Although the entire base class library has been broken into a number of discrete assemblies, the key assembly is _**mscorlib.dll**_, which contains a large number of core types that encapsulate a wide variety of common programming tasks, as well as the core data types used by all .NET languages.
## The Assembly/Namespace/Type Distinction
A _**namespace**_ is a grouping of semantically related types contained in an assembly or possibly spread across multiple related assemblies.

[W] This namespace provides a core body of types that you will need to leverage `time and again` as a .NET developer.

[W] Table 1-3 offers a `rundown` of some (but certainly not all) of the .NET namespaces grouped by related functionality.
### The Role of the Microsoft Root Namespace
### Accessing a Namespace Programmatically
[W] It is worth `reiterating` that a namespace is nothing more than a convenient way for us mere humans to logically understand and organize related types.
### Referencing External Assemblies
[T] GAC: Global Assembly Cache

>A vast majority of the .NET Framework assemblies are located under a specific directory termed the _**global assembly cache (GAC)**_. On a Windows machine, this can be located by default under *C:\Windows\Assembly*, as shown in Figure 1-6.

## Exploring an Assembly Using ildasm.exe
[W] Like any new set of prefabricated code, `you learn as you go`.

[T] The _**Intermediate Language Disassembler utility (ildasm.exe)**_, which ships with the .NET Framework 4.5 SDK, allows you to load up any .NET assembly and investigate its contents, including the associated manifest, CIL code, and type metadata.
### Viewing CIL Code
### Viewing Type Metadata
### Viewing Assembly Metadata (a.k.a. the Manifest)
## The Platform-Independent Nature of .NET
[W] To understand how this is possible, you need to `come to terms with` yet another abbreviation in the .NET universe: _**CLI(Common Language Infrastructure)**_.

[T] VES: Virtual Execution System

[W] ECMA-335 is the more `"meaty"` of the two specifications, `so much so that` it has been broken into various partitions, including those seen in Table 1-4.
## A Brief Word Regarding Windows 8 Applications
[W] They are also run in full-screen renderings and lack the usual `"chrome"` (e.g., menu systems, status bars, and toolbar buttons) we see in many desktop application.
### Building Windows 8 Applications
[T] Programming a Windows 8 application requires developers to tap into an entirely new runtime layer termed (appropriately enough) _**Windows Runtime (WinRT)**_.

[W] as luck would have it 다행히도, 공교롭게도, 우연히도 (as chance would have it)
* As it turned out; as it happened: *As luck would have it, it rained the day of the picnic.*

`As luck would have it`, the Windows.* namespaces offer functionality that mirrows many APIs of the .NET base class libraries.

[W] as well
+ In addition; also: mentioned other matters as well.
- With equal effect: I might as well go.

`As well`, many of the Windows.* namespaces offer similar (though not identical) funcionality as is found in the .NET base class libraries.

### The Role of .NET Under Windows 8
So the short answer is that the Microsoft .NET platform is alive and well under Windows 8, and will be a key part of your development efforts. Just keep in mind that .NET proper is not used to build Windows 8 applications. Rather, you will make use of new libraries (Windows.*), a new runtime (WinRT), and a subset of .NET proper (the .NET APIs) to create such a program.
## Summary
___
# 2. Building C# Applications
[W] proper  (prŏp′ər) [명사 뒤] 엄밀한 의미의
- 5. Being within the strictly limited sense, as of a term designating something: *the town proper, excluding the suburbs*
- 5. (immediately postpositive) (of an object, quality, etc) referred to or named specifically so as to exclude anything not directly connected with it: *his claim is connected with the deed proper.*
- 4. belonging or pertaining exclusively to a person, thing, or group.
- *The celebrations proper always begin on the last stroke of midnight.* 엄밀한 의미의 축하 행사는 자정을 알리는 마지막 타종 소리와 함께 시작된다.

The point of this chapter is to provide a tour of various .NET development options, including, of course, Visual Studio `proper`.

[W] Over the course of this chapter, you will encounter some C# syntax we have not formally examined. If you are unfamiliar with the syntax, don't `fret`.
## The Role of the .NET Framework 4.5 SDK
### The Developer Command Prompt
Many of these tools are driven from the command prompt, so if you wish to use these utilities from any Windows command window, you will need to register these paths with the operating system.

[W] As you can see, this command-line compiler has `a bevy of` options; however, in practice you will only need to make use of a handful of settings to build C# programs at the command prompt.

[W] `In this light`, it’s `edifying` to see what takes place behind the scenes.
## Building C# Applications Using csc.exe
### Specifying Input and Output Targets
[W] Recall that when you explicitly list the namespaces used within a given *.cs file, you avoid the need to make use of fully qualified names of a type (which can lead to `hand cramps`).
### Referencing External Assemblies
### Referencing Multiple External Assemblies
### Compiling Multiple Source Files
### Working with C# Response Files
[W] To help lessen your typing burden, the C# compiler `honors` the use of response files.
### The Default Response File (csc.rsp)
`c:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.rsp`
## Building .NET Applications Using Notepad++
## Building .NET Applications Using SharpDevelop
### Building a Simple Test Project
## Building .NET Applications Using Visual C# Express
### Some Unique Features of Visual C# Express
## Building .NET Applications Using Visual Studio
[W] staggering (stăg′ər-ĭng)
- Causing great astonishment, amazement, or dismay; overwhelming: `a staggering achievement; a staggering defeat.`

There are a `staggering` number of members within the Visual Studio family.
### Some Unique Features of Visual Studio
[W] at that
- In addition; besides: `lived in one room, and a small room at that.`
- Regardless of what has been said or implied: `a long shot, but she just might win at that.`

To be completely honest, Visual Studio provides so many features that it would take an entire book (`a rather large book at that`) to fully describe every aspect of the IDE.
### Targeting the .NET Framework Using the New Project Dialog Box
### Using the Solution Explorer Utility
#### Referencing External Assemblies
[W] Also, the very useful Recent tab `keeps a running tally` of frequently referenced assemblies you have used in other projects.

[W] `By way of` a simple test, locate the System.Windows.Forms.dll assembly from the Framework area, and check the related check box.
####Viewing Project Properties
### The Class View Utility
### The Object Browser Utility
### Integrated Support for Code Refactoring
### Code Snippets and Surround with Technology
### The Visual Class Designer
### The Integrated .NET Framework 4.5 SDK Documentation System
[W] Given the huge number of predefined .NET types (which `number well into` the thousands), you must be willing to roll up your sleeves and dig into the provided documentation.

[W] after the fact, done, made, or formulated after something has occurred.

If you wish to perform a local installation of the help system `after the fact`, navigate to the All Programs->Microsoft Visual Studio 11->Microsoft Help Viewer tool using your Windows Start button.

[W] `At the risk of` sounding like a broken record, I really can’t emphasize enough how important it is that you learn to use the .NET Framework 4.5 SDK documentation. 
## Summary
___
# 3. Core C# Programming Constructs, Part I
## The Anatomy of a Simple C# Program
[W] You might agree that the code within the initial Program.cs file is rather `uneventful`.

[T] Formally speaking, the class that defines the Main() method is termed the _**application object**_.

_**static keyword**_: can thus be invoked without the need to first create a new class instance.

Among its set of members is the static _**WriteLine()**_ which, as you might assume, sends a text string and carriage return to the standard output.
### Variations on the Main() Method
### Specifying an Application Error Code
be aware that the _**value 0 is automatically returned**_, even if you construct a Main() method prototyped to return void.

[T] **%ERRORLEVEL%**: echo %ERRORLEVEL% (System.Diagnostics.Process.ExitCode)
### Processing Command-Line Arguments
### Specifying Command-Line Arguments with Visual Studio
## An Interesting Aside: Some Additional Members of the System.Environment Class
## The System.Console Class
[W] As you can see, the Console class does provide some members that can `spice-up` a simple command-line application, such as the ability to change background and foreground colors and issue beep noises (in a variety of frequencies!).
### Basic Input and Output with the Console Class
### Formatting Console Output
The .NET platform supports a style of string formatting slightly akin to the printf() statement of C. Simply put, when you are defining a string literal that contains segments of data whose value is `not known until runtime`, you are able to specify a placeholder within the literal using this curly-bracket syntax.

[W] `Be very aware that` the first ordinal number of a curly-bracket placeholder always begins with 0.

[W] `Also know that` it is possible to position each placeholder in any location within a string literal, and it need not follow an increasing sequence.
### Formatting Numerical Data
### Formatting Numerical Data Beyond Console Applications
## System Data Types and Corresponding C# Keywords
### Variable Declaration and Initialization
### Intrinsic Data Types and the new Operator
### The Data Type Class Hierarchy
### Members of Numerical Data Types
### Members of System.Boolean
### Members of System.Char
### Parsing Values from String Data
### System.DateTime and System.TimeSpan
### The System.Numerics.dll Assembly
## Working with String Data
### Basic String Manipulation
### String Concatenation
### Escape Characters
[W] rusty (rŭs′tē)
- out of practice; impaired in skill or knowledge by inaction or neglect

In case you are a bit `rusty` on the meanings behind these escape characters, Table 3-6 lists the more common optins.
### Defining Verbatim Strings
### Strings and Equality
### Strings Are Immutable
[W] flat-out (flăt′out′)
-  Thoroughgoing; out-and-out: *a flat-out promotional campaign*; *a flat-out deception.*

1 using full speed or all of one's resources: *a flat-out effort.*
2 downright: *a flat-out forgery.* 

At first glance, this might seem like a `flat-out` lie, given that we are always reassigning strings to new values and because System.String type defines a number of methods that appear to modify the character data in one way or another (such as uppercasing and lowercasing).

### The System.Text.StringBuilder Type
[W] abandon (ə-băn′dən) 방종, 자유분방
- Great enthusiasm or lack of restraint: *skied with abandon.*
- *He signed cheques with careless abandon.*

Given that the string type can be inefficient when used `with reckless abandon', the .NET base class libraries provide the System.Text namespace.

[W] When you wish to use this type in your C# code files, your first step is to make sure the following namespace is imported into your code file (`this should already be the case` for a new Visual Studio project): *using Sysem.Text;*
## Narrowing and Widening Data Type Conversions
[W] Although this implicit widening worked `in our favor` for the previous example, other times this "feature" can be the source of compile-time errors.
### The checked Keyword
[W] By default, if you `take no corrective course of action`, overflow/underflow conditions occur without error.
### Setting Project-Wide Overflow Checking
### The unchecked Keyword
[W] discrete (dĭ-skrēt′)
- separate, individual, distinct, detached, disconnected, unattached, discontinuous *the process seen as a sequence of discrete phases*

When you want to selectively handle `discrete` statements, make use of the checked keyword.
## Understanding Implicitly Typed Local Variables
[W] yours truly, an informal term for I, myself, or me
- I, myself, or me: *"Let me talk about a typical day in the life of yours truly" (Robert A. Spivey).*

While many (including `yours truly`) would argue that it is always good practice to explicitly specify the data type of each variable, the C# language does provide for implicitly typing of local variables using the *var* keyword.

Strictly speaking, **var** is not a C# keyword.

[T] You can verify this by printing out the type name via **reflection**. As you will see in much more detail in Chapter 15, **reflection** is the act of determining the composition of a type at runtime.
### Restrictions on Implicitly Typed Variables
[W] It is `permissible`, however, to assign an inferred local variable to null after its initial assignment (provided it is a reference type).
### Implicit Typed Data Is Strongly Typed Data
### Usefulness of Implicitly Typed Local Variables
[W] First and foremost, using **var** to declare local variables simply for the sake of doing so really `brings little to the table`.

[W] Withought `getting hung up on` the following LINQ example code, see if you can figure out the underlying data type of subset:
## C# Iteration Constructs
[W] I will keep this final section of the chapter short and `to the point`, as I am assuming you have experience using similar keywords (if, for, switch, etc.) in you current programming language.

[W] Without `belaboring` the point, here is a sample of the syntax.
### The for Loop
### The foreach Loop
#### Use of Implicit Typing Within foreach Constructs
### The while and do/while Looping Constructs
## Decision Constructs and the Relational/Equality Operators
### The if/else Statement
[W] `First up` is the if/else statement.

Unlike C and C++, the if/else statement in C# operates on on Boolean expression, **not ad hoc values** such as -1 or0.
### Equality and Relational Operators
### Conditional Operators
### The switch Statement
[W] whet (wĕt, hwĕt)
- stimulate, increase, excite, stir, enhance, provoke, arouse, awaken, animate, rouse, quicken, incite, kindle, pique `a delicious aroma which whetted our appetites`

To `whet your appetite`, consider the following final helper function, which performs a switch test on the System.DayOfWeek enum.
## Summary
___
# 4. Core C# Programming Constructs, Part II
## Methods and Parameter Modifiers
### The Default by Value Parameter-Passing Behavior
### The out Modifier
### The ref Modifier
### The params Modifier
### Defining Optional Parameters
### Invoking Methods Using Named Parameters
### Understanding Method Overloading
[W] As explained in Chapter 9, it is possible to build generic methods that `take the concept of overloading to the next level`.
## Understanding C# Arrays
### C# Array Initialization Syntax
### Implicitly Typed Local Arrays
[W] `In a similar vein`, the *var* keyword can be used to define implicitly typed local arrays.
### Defining an Array of Objects
### Working with Multidimensional Arrays
### Arrays As Arguments or Return Values
### The System.Array Base Class
[W] rundown (rŭn′doun′)
- A point-by-point summary.
- recapitulation, run-through, sum, summary, summation, summing-up, wrap-up.
- Informal: recap.

Table 4-2 gives a `rundown` of some of the more interesting members (be sure to check the .NET Framework 4.5 SDK documentation for full details).
## Understanding the enum Type
[W] grunt (grŭnt)
- Slang One who performs routine or mundane tasks.
- an unskilled or low-ranking soldier or other worker; *"infantrymen in Vietnam were called grunts"; "he went from grunt to chairman in six years"*
- unskilled person - a person who lacks technical training

For example, if you are creating a payroll system, you might want to refer to the type of employees using constants such as vice president, manager, contractor, and `grunt`.

[W] C# supports the notion of custom enumerations `for this very reason`.

[W] By default, the first element is set to the value zero (0), followed by an n+1 `progression`.
### Controlling the Underlying Storage for an enum
[W] conserve (kən-sûrv′)
- To use carefully or sparingly, avoiding waste: *kept the thermostat lower to conserve energy.*
- To economize: *tried to conserve on fuel during the long winter.*
- use cautiously and frugally; *"I try to economize my spare time"; "conserve your energy for the ascent to the summit"*
- economize, husband, economise
- save, preserve - to keep up and reserve for personal or special use; *"She saved the old family photographs in a drawer"*
- retrench - tighten one's belt; use resources carefully
- squander, waste, blow - spend thoughtlessly; throw away; *"He wasted his inheritance on his insincere friends"; "You squandered the opportunity to get and advanced degree"*

Changing the underlying type of an enumeration can be helpful if you are building a .NET application that will be deployed to a low-memory device (such as a Windows Phone 7 device) and need to `conserve` memory wherever possible.
### Declaring enum Variables
### The System.Enum Type
### Dynamically Discovering an enum’s Name/Value Pairs
## Understanding the Structure Type
[W] On the surface, the process of defining and using structures is very simple, but as they say, `the devil is in the details`.
### Creating Structure Variables
## Understanding Value Types and Reference Types
Simply put, the role of **System.ValueType** is to ensure that the derived type (e.g., any structure) is allocated on the *stack*, rather than the garbage-collected *heap*.

Functionally, the only purpose of **System.ValueType** is to override the virtual methods defined by **System.Object** to use value-based, versus reference-based, semantics. The base class of ValueType is System.Object. In fact, the instance methods defined by **System.ValueType** are identical to those of *System.Object*:
### Value Types, References Types, and the Assignment Operator
### Value Types Containing Reference Types
### Passing Reference Types by Value
### Passing Reference Types by Reference
### Final Details Regarding Value Types and Reference Types
## Understanding C# Nullable Types
**Value types** can never be assigned the value of **null**, as that is used to establish an empty object reference.

To define a nullable variable type, the question mark symbol(**?**) is suffixed to the underlying data type. Do note that *this syntax is only legal when applied to value types*.
### Working with Nullable Types
### The ?? Operator
## Summary
___
# 5. Understanding Encapsulation
[W] commonplace (kŏm′ən-plās′)
- commonplace - completely ordinary and unremarkable; *"air travel has now become commonplace"; "commonplace everyday activities"*
- ordinary - not exceptional in any way especially in quality or ability or size or degree; *"ordinary everyday objects"; "ordinary decency"; "an ordinary day"; "an ordinary wine"*

In the Chapters 3 and 4, you investigated a number of core syntactical constructs that are `commonplace` to any .NET application you might be developing.

[W] `The first order of business` is to examine the process of building well-defined class types that support any number of constructors.
## Introducing the C# Class Type
Recall the term **"object"** is used to describe an instance of a given class type created using the **new** keyword.

[W] fit the bill
- fit the bill - be what is needed or be good enough for what is required; *"Does this restaurant fit the bill for the celebration?"*
- ===fill the bill - conform to, fit, meet - satisfy a condition or restriction; *"Does this paper meet the requirements for the degree?"*

However to keep this example as simple as possible, pubic data `fits the bill`.
### Allocating Objects with the new Keyword
## Understanding Constructors
[W] However, it is `not uncommon` for a class to have dozens of fields to `contend with`.
### The Role of the Default Constructor
[W] freebee (frē′bē)
- freebee - something that is free (usually provided as part of a promotional scheme); *"the road map was a freebie"*
- =freebie
- <->gift - something acquired without compensation

Every C# class is provided with a `freebee` default constructor that you may redefine `if need be`.
### Defining Custom Constructors
### The Default Constructor Revisited
## The Role of the this Keyword
### Chaining Constructor Calls Using this
[W] While this is `all well and good`, you do have redundant code statements in two constructors.
### Observing Constructor Flow
### Revisiting Optional Arguments
## Understanding the static Keyword
### Defining Static Field Data
### Defining Static Methods
### Defining Static Constructors
### Defining Static Classes
## Defining the Pillars of OOP
### The Role of Encapsulation
### The Role of Inheritance
### The Role of Polymorphism
## C# Access Modifiers
### The Default Access Modifiers
### Access Modifiers and Nested Types
## The First Pillar: C#’s Encapsulation Services
### Encapsulation Using Traditional Accessors and Mutators
### Encapsulation Using .NET Properties
### Using Properties Within a Class Definition
### Read-Only and Write-Only Properties
### Revisiting the static Keyword: Defining Static Properties
## Understanding Automatic Properties
### Interacting with Automatic Properties
### Regarding Automatic Properties and Default Values
## Understanding Object Initialization Syntax
### Calling Custom Constructors with Initialization Syntax
### Initializing Inner Types
## Working with Constant Field Data
### Understanding Read-Only Fields
### Static Read-Only Fields
## Understanding Partial Types
## Summary
___
# 6. Understanding Inheritance and 6. Polymorphism
## The Basic Mechanics of Inheritance
### Specifying the Parent Class of an Existing Class
### Regarding Multiple Base Classes
### The sealed Keyword
## Revising Visual Studio Class Diagrams
## The Second Pillar of OOP: The Details of Inheritance
### Controlling Base Class Creation with the base Keyword
### Keeping Family Secrets: The protected Keyword
### Adding a Sealed Class
## Programming for Containment/Delegation
### Understanding Nested Type Definitions
## The Third Pillar of OOP: C#’s Polymorphic Support
### The virtual and override Keywords
### Overriding Virtual Members Using the Visual Studio IDE
### Sealing Virtual Members
### Understanding Abstract Classes
### Understanding the Polymorphic Interface
### Understanding Member Shadowing
## Understanding Base Class/Derived Class Casting Rules
### The C# as Keyword
### The C# is Keyword
## The Master Parent Class: System.Object
### Overriding System.Object.ToString()
### Overriding System.Object.Equals()
### Overriding System.Object.GetHashCode()
### Testing Your Modified Person Class
### The Static Members of System.Object
## Summary
___
# 7. Understanding Structured Exception 7. Handling
## Ode to Errors, Bugs, and Exceptions
## The Role of .NET Exception Handling
### The Building Blocks of .NET Exception Handling
### The System.Exception Base Class
## The Simplest Possible Example
### Throwing a General Exception
### Catching Exceptions
## Configuring the State of an Exception
### The TargetSite Property
### The StackTrace Property
### The HelpLink Property
### The Data Property
## System-Level Exceptions (System.SystemException)
## Application-Level Exceptions (System.ApplicationException)
### Building Custom Exceptions, Take One
### Building Custom Exceptions, Take Two
### Building Custom Exceptions, Take Three
## Processing Multiple Exceptions
### General catch Statements
### Rethrowing Exceptions
### Inner Exceptions
### The finally Block
## Who Is Throwing What?
## The Result of Unhandled Exceptions
## Debugging Unhandled Exceptions Using Visual Studio
## Summary
___
# 8. Working with Interfaces
## Understanding Interface Types
### Interface Types vs. Abstract Base Classes
## Defining Custom Interfaces
## Implementing an Interface
## Invoking Interface Members at the Object Level
### Obtaining Interface References: The as Keyword
### Obtaining Interface References: The is Keyword
## Interfaces As Parameters
## Interfaces As Return Values
## Arrays of Interface Types
## Implementing Interfaces Using Visual Studio
## Explicit Interface Implementation
## Designing Interface Hierarchies
### Multiple Inheritance with Interface Types
## The IEnumerable and IEnumerator Interfaces
### Building Iterator Methods with the yield Keyword
### Building a Named Iterator
## The ICloneable Interface
### A More Elaborate Cloning Example
## The IComparable Interface
### Specifying Multiple Sort Orders with IComparer
### Custom Properties and Custom Sort Types
## Summary
___
# 9. Collections and Generics
## The Motivation for Collection Classes
### The System.Collections Namespace
### A Survey of System.Collections.Specialized Namespace
## The Problems of Nongeneric Collections
### The Issue of Performance
### The Issue of Type Safety
### A First Look at Generic Collections
## The Role of Generic Type Parameters
### Specifying Type Parameters for Generic Classes/Structures
### Specifying Type Parameters for Generic Members
### Specifying Type Parameters for Generic Interfaces
## The System.Collections.Generic Namespace
### Understanding Collection Initialization Syntax
### Working with the List<T> Class
### Working with the Stack<T> Class
### Working with the Queue<T> Class
### Working with the SortedSet<T> Class
## The System.Collections.ObjectModel Namespace
### Working with ObservableCollection<T>
## Creating Custom Generic Methods
### Inference of Type Parameters
## Creating Custom Generic Structures and Classes
### The default Keyword in Generic Code
## Constraining Type Parameters
### Examples Using the where Keyword
### The Lack of Operator Constraints
## Summary
___
# 10. Delegates, Events, and Lambda Expressions
## Understanding the .NET Delegate Type
### Defining a Delegate Type in C#
### The System.MulticastDelegate and System.Delegate Base Classes
## The Simplest Possible Delegate Example
### Investigating a Delegate Object
## Sending Object State Notifications Using Delegates
### Enabling Multicasting
### Removing Targets from a Delegate’s Invocation List
### Method Group Conversion Syntax
## Understanding Generic Delegates
### The Generic Action<> and Func<> Delegates
## Understanding C# Events
### The C# event Keyword
### Events Under the Hood
### Listening to Incoming Events
### Simplifying Event Registration Using Visual Studio
### Creating Custom Event Arguments
### The Generic EventHandler<T> Delegate
## Understanding C# Anonymous Methods
### Accessing Local Variables
## Understanding Lambda Expressions
### Dissecting a Lambda Expression
### Processing Arguments Within Multiple Statements
### Lambda Expressions with Multiple (or Zero) Parameters
### Retrofitting the CarEvents Example Using Lambda Expressions
## Summary
___
# 11. Advanced C# Language Features
## Understanding Indexer Methods
### Indexing Data Using String Values
### Overloading Indexer Methods
### Indexers with Multiple Dimensions
### Indexer Definitions on Interface Types
## Understanding Operator Overloading
### Overloading Binary Operators
### And What of the += and –+ Operators?
### Overloading Unary Operators
### Overloading Equality Operators
### Overloading Comparison Operators
### Final Thoughts Regarding Operator Overloading
## Understanding Custom Type Conversions
### Recall: Numerical Conversions
### Recall: Conversions Among Related Class Types
### Creating Custom Conversion Routines
### Additional Explicit Conversions for the Square Type
### Defining Implicit Conversion Routines
## Understanding Extension Methods
### Defining Extension Methods
### Invoking Extension Methods
### Importing Extension Methods
### The IntelliSense of Extension Methods
### Extending Types Implementing Specific Interfaces
## Understanding Anonymous Types
### Defining an Anonymous Type
### The Internal Representation of Anonymous Types
### The Implementation of ToString() and GetHashCode()
### The Semantics of Equality for Anonymous Types
### Anonymous Types Containing Anonymous Types
## Working with Pointer Types
### The unsafe Keyword
### Working with the * and & Operators
### An Unsafe (and Safe) Swap Function
### Field Access via Pointers (the -> Operator)
### The stackalloc Keyword
### Pinning a Type via the fixed Keyword
### The sizeof Keyword
## Summary
___
# 12. LINQ to Objects
## LINQ-Specific Programming Constructs
### Implicit Typing of Local Variables
### Object and Collection Initialization Syntax
### Lambda Expressions
### Extension Methods
### Anonymous Types
## Understanding the Role of LINQ
### LINQ Expressions Are Strongly Typed
### The Core LINQ Assemblies
## Applying LINQ Queries to Primitive Arrays
### Once Again, Without LINQ
### Reflecting over a LINQ Result Set
### LINQ and Implicitly Typed Local Variables
### LINQ and Extension Methods
### The Role of Deferred Execution
### The Role of Immediate Execution
## Returning the Result of a LINQ Query
### Returning LINQ Results via Immediate Execution
## Applying LINQ Queries to Collection Objects
### Accessing Contained Subobjects
### Applying LINQ Queries to Nongeneric Collections
### Filtering Data Using OfType<T>()
## Investigating the C# LINQ Query Operators
### Basic Selection Syntax
### Obtaining Subsets of Data
### Projecting New Data Types
### Obtaining Counts Using Enumerable
### Reversing Result Sets
### Sorting Expressions
### LINQ As a Better Venn Diagramming Tool
### Removing Duplicates
### LINQ Aggregation Operations
## The Internal Representation of LINQ Query Statements
### Building Query Expressions with Query Operators (Revisited)
### Building Query Expressions Using the Enumerable Type and Lambda Expressions
### Building Query Expressions Using the Enumerable Type and Anonymous Methods
### Building Query Expressions Using the Enumerable Type and Raw Delegates
## Summary
___
# 13. Understanding Object Lifetime
## Classes, Objects, and References
## The Basics of Object Lifetime
### The CIL of new
### Setting Object References to null
## The Role of Application Roots
## Understanding Object Generations
## Concurrent Garbage Collection Under .NET 1.0–3.5
## Background Garbage Collection Under .NET 4.0 and Greater
## The System.GC Type
### Forcing a Garbage Collection
## Building Finalizable Objects
### Overriding System.Object.Finalize()
### Detailing the Finalization Process
## Building Disposable Objects
### Reusing the C# using Keyword
## Building Finalizable and Disposable Types
### A Formalized Disposal Pattern
## Understanding Lazy Object Instantiation
### Customizing the Creation of the Lazy Data
## Summary
___
# 14. Building and Configuring Class Libraries
## Defining Custom Namespaces
### Resolving Name Clashes with Fully Qualified Names
### Resolving Name Clashes with Aliases
### Creating Nested Namespaces
### The Default Namespace of Visual Studio
## The Role of .NET Assemblies
### Assemblies Promote Code Reuse
### Assemblies Establish a Type Boundary
### Assemblies Are Versionable Units
### Assemblies Are Self-Describing
### Assemblies Are Configurable
## Understanding the Format of a .NET Assembly
### The Windows File Header
### The CLR File Header
### CIL Code, Type Metadata, and the Assembly Manifest
### Optional Assembly Resources
## Building and Consuming Custom Class Library
### Exploring the Manifest
### Exploring the CIL
### Exploring the Type Metadata
### Building a C# Client Application
### Building a Visual Basic Client Application
### Cross-Language Inheritance in Action
## Understanding Private Assemblies
### The Identity of a Private Assembly
### Understanding the Probing Process
### Configuring Private Assemblies
### The Role of the App.Config File
## Understanding Shared Assemblies
### The Global Assembly Cache
### Understanding Strong Names
### Generating Strong Names at the Command Line
### Generating Strong Names Using Visual Studio
### Installing Strongly Named Assemblies to the GAC
## Consuming a Shared Assembly
### Exploring the Manifest of SharedCarLibClient
## Configuring Shared Assemblies
### Freezing the Current Shared Assembly
### Building a Shared Assembly Version 2.0.0.0
### Dynamically Redirecting to Specific Versions of a Shared Assembly
## Understanding Publisher Policy Assemblies
### Disabling Publisher Policy
## Understanding the <codeBase> Element
## The System.Configuration Namespace
## The Configuration File Schema Documentation
## Summary
___
# 15. Type Reflection, Late Binding, and Attribute-Based Programming
## The Necessity of Type Metadata
### Viewing (Partial) Metadata for the EngineState Enumeration
### Viewing (Partial) Metadata for the Car Type
### Examining a TypeRef
### Documenting the Defining Assembly
### Documenting Referenced Assemblies
### Documenting String Literals
## Understanding Reflection
### The System.Type Class
### Obtaining a Type Reference Using System.Object.GetType()
### Obtaining a Type Reference Using typeof()
### Obtaining a Type Reference Using System.Type.GetType()
## Building a Custom Metadata Viewer
### Reflecting on Methods
### Reflecting on Fields and Properties
### Reflecting on Implemented Interfaces
### Displaying Various Odds and Ends
### Implementing Main()
### Reflecting on Generic Types
### Reflecting on Method Parameters and Return Values
## Dynamically Loading Assemblies
## Reflecting on Shared Assemblies
## Understanding Late Binding
### The System.Activator Class
### Invoking Methods with No Parameters
### Invoking Methods with Parameters
## Understanding the Role of .NET Attributes
### Attribute Consumers
### Applying Attributes in C#
### C# Attribute Shorthand Notation
### Specifying Constructor Parameters for Attributes
### The Obsolete Attribute in Action
## Building Custom Attributes
### Applying Custom Attributes
### Named Property Syntax
### Restricting Attribute Usage
## Assembly-Level Attributes
### The Visual Studio AssemblyInfo.cs File
## Reflecting on Attributes Using Early Binding
## Reflecting on Attributes Using Late Binding
## Putting Reflection, Late Binding, and Custom Attributes in Perspective
## Building an Extendable Application
### Building CommonSnappableTypes.dll
### Building the C# Snap-In
### Building the Visual Basic Snap-In
### Building an Extendable Windows Forms Application
## Summary
___
# 16. Dynamic Types and the Dynamic Language Runtime
## The Role of the C# dynamic Keyword
### Calling Members on Dynamically Declared Data
### The Role of the Microsoft.CSharp.dll Assembly
### The Scope of the dynamic Keyword
### Limitations of the dynamic Keyword
### Practical Uses of the dynamic Keyword
## The Role of the Dynamic Language Runtime (DLR)
### The Role of Expression Trees
### The Role of the System.Dynamic Namespace
### Dynamic Runtime Lookup of Expression Trees
## Simplifying Late-Bound Calls Using Dynamic Types
### Leveraging the dynamic Keyword to Pass Arguments
## Simplifying COM Interoperability Using Dynamic Data
### The Role of Primary Interop Assemblies (PIAs)
### Embedding Interop Metadata
### Common COM Interop Pain Points
## COM Interop Using C# Dynamic Data
### COM interop Without C# Dynamic Data
## Summary
___
# 17. Processes, AppDomains, and Object Contexts
## The Role of a Windows Process
### The Role of Threads
## Interacting with Processes Under the .NET Platform
### Enumerating Running Processes
### Investigating a Specific Process
### Investigating a Process’s Thread Set
### Investigating a Process’s Module Set
### Starting and Stopping Processes Programmatically
### Controlling Process Startup Using the ProcessStartInfo Class
## Understanding .NET Application Domains
### The System.AppDomain Class
## Interacting with the Default Application Domain
### Enumerating Loaded Assemblies
### Receiving Assembly Load Notifications
## Creating New Application Domains
### Loading Assemblies into Custom Application Domains
### Programmatically Unloading AppDomains
## Understanding Object Context Boundaries
### Context-Agile and Context-Bound Types
### Defining a Context-Bound Object
### Inspecting an Object’s Context
## Summarizing Processes, AppDomains, and Context
## Summary
___
# 18. Understanding CIL and the Role of Dynamic Assemblies
## Reasons for Learning the Grammar of CIL
## Examining CIL Directives, Attributes, and Opcodes
### The Role of CIL Directives
### The Role of CIL Attributes
### The Role of CIL Opcodes
### The CIL Opcode/CIL Mnemonic Distinction
## Pushing and Popping: The Stack-Based Nature of CIL
## Understanding Round-Trip Engineering
### The Role of CIL Code Labels
### Interacting with CIL: Modifying an *.il File
### Compiling CIL Code Using ilasm.exe
### The Role of peverify.exe
## Understanding CIL Directives and Attributes
### Specifying Externally Referenced Assemblies in CIL
### Defining the Current Assembly in CIL
### Defining Namespaces in CIL
### Defining Class Types in CIL
### Defining and Implementing Interfaces in CIL
### Defining Structures in CIL
### Defining Enums in CIL
### Defining Generics in CIL
### Compiling the CILTypes.il file
##.NET Base Class Library, C#, and CIL Data Type Mappings
## Defining Type Members in CIL
### Defining Field Data in CIL
### Defining Type Constructors in CIL
### Defining Properties in CIL
### Defining Member Parameters
## Examining CIL Opcodes
### The .maxstack Directive
### Declaring Local Variables in CIL
### Mapping Parameters to Local Variables in CIL
### The Hidden this Reference
### Representing Iteration Constructs in CIL
## Building a .NET Assembly with CIL
### Building CILCars.dll
### Building CILCarClient.exe
## Understanding Dynamic Assemblies
### Exploring the System.Reflection.Emit Namespace
### The Role of the System.Reflection.Emit.ILGenerator
### Emitting a Dynamic Assembly
### Emitting the Assembly and Module Set
### The Role of the ModuleBuilder Type
### Emitting the HelloClass Type and the String Member Variable
### Emitting the Constructors
### Emitting the SayHello() Method
### Using the Dynamically Generated Assembly
## Summary
___
# 19. Multithreaded, Parallel, and Async Programming
## The Process/AppDomain/Context/Thread Relationship
### The Problem of Concurrency
### The Role of Thread Synchronization
## A Brief Review of the .NET Delegate
## The Asynchronous Nature of Delegates
### The BeginInvoke() and EndInvoke() Methods
### The System.IAsyncResult Interface
## Invoking a Method Asynchronously
### Synchronizing the Calling Thread
### The Role of the AsyncCallback Delegate
### The Role of the AsyncResult Class
### Passing and Receiving Custom State Data
## The System.Threading Namespace
## The System.Threading.Thread Class
### Obtaining Statistics About the Current Thread of Execution
### The Name Property
### The Priority Property
## Manually Creating Secondary Threads
### Working with the ThreadStart Delegate
### Working with the ParameterizedThreadStart Delegate
### The AutoResetEvent Class
### Foreground Threads and Background Threads
## The Issue of Concurrency
### Synchronization Using the C# lock Keyword
### Synchronization Using the System.Threading.Monitor Type
### Synchronization Using the System.Threading.Interlocked Type
### Synchronization Using the [Synchronization] Attribute
## Programming with Timer Callbacks
## Understanding the CLR ThreadPool
## Parallel Programming Using the Task Parallel Library
### The System.Threading.Tasks Namespace
### The Role of the Parallel Class
### Data Parallelism with the Parallel Class
### Accessing UI Elements on Secondary Threads
### The Task Class
### Handling Cancellation Request
### Task Parallelism Using the Parallel Class
## Parallel LINQ Queries (PLINQ)
### Opting in to a PLINQ Query
### Cancelling a PLINQ Query
## Asynchronous Calls Under .NET 4.5
### A First Look at the C# async and await Keywords
### Naming Conventions for Async Methods
### Async Methods Returning Void
### Async Methods with Multiple Awaits
### Retrofitting the AddWithThreads Example Using Asycn/Await
## Summary
___
# 20. File I/O and Object Serialization
## Exploring the System.IO Namespace
## The Directory(Info) and File(Info) Types
### The Abstract FileSystemInfo Base Class
## Working with the DirectoryInfo Type
### Enumerating Files with the DirectoryInfo Type
### Creating Subdirectories with the DirectoryInfo Type
## Working with the Directory Type
## Working with the DriveInfo Class Type
## Working with the FileInfo Class
### The FileInfo.Create() Method
### The FileInfo.Open() Method
### The FileInfo.OpenRead() and FileInfo.OpenWrite() Methods
### The FileInfo.OpenText() Method
### The FileInfo.CreateText() and FileInfo.AppendText() Methods
## Working with the File Type
### Additional File-Centric Members
## The Abstract Stream Class
### Working with FileStreams
## Working with StreamWriters and StreamReaders
### Writing to a Text File
### Reading from a Text File
### Directly Creating StreamWriter/StreamReader Types
## Working with StringWriters and StringReaders
## Working with BinaryWriters and BinaryReaders
## Watching Files Programmatically
## Understanding Object Serialization
### The Role of Object Graphs
## Configuring Objects for Serialization
### Defining Serializable Types
### Public Fields, Private Fields, and Public Properties
## Choosing a Serialization Formatter
### The IFormatter and IRemotingFormatter Interfaces
### Type Fidelity Among the Formatters
## Serializing Objects Using the BinaryFormatter
### Deserializing Objects Using the BinaryFormatter
## Serializing Objects Using the SoapFormatter
## Serializing Objects Using the XmlSerializer
### Controlling the Generated XML Data
## Serializing Collections of Objects
## Customizing the Soap/Binary Serialization Process
### A Deeper Look at Object Serialization
### Customizing Serialization Using ISerializable
### Customizing Serialization Using Attributes
## Summary
___
# 21. ADO.NET Part I: The Connected Layer
## A High-Level Definition of ADO.NET
### The Three Faces of ADO.NET
## Understanding ADO.NET Data Providers
### The Microsoft-Supplied ADO.NET Data Providers
### A Word Regarding System.Data.OracleClient.dll
### Obtaining Third-Party ADO.NET Data Providers
## Additional ADO.NET Namespaces
## The Types of the System.Data Namespace
### The Role of the IDbConnection Interface
### The Role of the IDbTransaction Interface
### The Role of the IDbCommand Interface
### The Role of the IDbDataParameter and IDataParameter Interfaces
### The Role of the IDbDataAdapter and IDataAdapter Interfaces
### The Role of the IDataReader and IDataRecord Interfaces
## Abstracting Data Providers Using Interfaces
### Increasing Flexibility Using Application Configuration Files
## Creating the AutoLot Database
### Creating the Inventory Table
### Adding Test Records to the Inventory Table
### Authoring the GetPetName() Stored Procedure
### Creating the Customers and Orders Tables
### Visually Creating Table Relationships
## The ADO.NET Data Provider Factory Model
### A Complete Data Provider Factory Example
### A Potential Drawback with the Data Provider Factory Model
### The <connectionStrings> Element
## Understanding the Connected Layer of ADO.NET
### Working with Connection Objects
### Working with ConnectionStringBuilder Objects
### Working with Command Objects
## Working with Data Readers
### Obtaining Multiple Result Sets Using a Data Reader
## Building a Reusable Data Access Library
### Adding the Connection Logic
### Adding the Insertion Logic
### Adding the Deletion Logic
### Adding the Update Logic
### Adding the Selection Logic
### Working with Parameterized Command Objects
### Executing a Stored Procedure
## Creating a Console UI–Based Front End
### Implementing the Main() Method
### Implementing the ShowInstructions() Method
### Implementing the ListInventory() Method
### Implementing the DeleteCar() Method
### Implementing the InsertNewCar() Method
### Implementing the UpdateCarPetName() Method
### Implementing LookUpPetName()
## Understanding Database Transactions
### Key Members of an ADO.NET Transaction Object
### Adding a CreditRisks Table to the AutoLot Database
### Adding a Transaction Method to InventoryDAL
### Testing Your Database Transaction
## Summary
___
# 22. ADO.NET Part II: The Disconnected Layer
## Understanding the Disconnected Layer of ADO.NET
## Understanding the Role of the DataSet
### Key Properties of the DataSet
### Key Methods of the DataSet
### Building a DataSet
## Working with DataColumns
### Building a DataColumn
### Enabling Autoincrementing Fields
### Adding DataColumn Objects to a DataTable
## Working with DataRows
### Understanding the RowState Property
### Understanding the DataRowVersion Property
## Working with DataTables
### Inserting DataTables into DataSets
### Obtaining Data in a DataSet
### Processing DataTable Data Using DataTableReader Objects
### Serializing DataTable/DataSet Objects As XML
### Serializing DataTable/DataSet Objects in a Binary Format
## Binding DataTable Objects to Windows Forms GUIs
### Hydrating a DataTable from a Generic List<T>
### Deleting Rows from a DataTable
### Selecting Rows Based on Filter Criteria
### Updating Rows Within a DataTable
### Working with the DataView Type
## Working with Data Adapters
### A Simple Data Adapter Example
### Mapping Database Names to Friendly Names
## Adding Disconnection Functionality to AutoLotDAL.dll
### Defining the Initial Class Type
### Configuring the Data Adapter Using the SqlCommandBuilder
### Implementing GetAllInventory()
### Implementing UpdateInventory()
### Setting Your Version Number
### Testing the Disconnected Functionality
## Multitabled DataSet Objects and Data Relationships
### Prepping the Data Adapters
### Building the Table Relationships
### Updating the Database Tables
### Navigating Between Related Tables
## The Windows Forms Database Designer Tools
### Visually Designing the DataGridView
### The Generated App.config File
### Examining the Strongly Typed DataSet
### Examining the Strongly Typed DataTable
### Examining the Strongly Typed DataRow
### Examining the Strongly Typed Data Adapter
### Completing the Windows Forms Application
## Isolating Strongly Typed Database Code into a Class Library
### Viewing the Generated Code
### Selecting Data with the Generated Code
### Inserting Data with the Generated Code
### Deleting Data with the Generated Code
### Invoking a Stored Procedure Using the Generated Code
## Programming with LINQ to DataSet
### The Role of the DataSet Extensions Library
### Obtaining a LINQ-Compatible DataTable
### The Role of the DataRowExtensions.Field<T>() Extension Method
### Hydrating New DataTables from LINQ Queries
## Summary
___
# 23. ADO.NET Part III: The Entity Framework
## Understanding the Role of Entity Framework
### The Role of Entities
### The Building Blocks of the Entity Framework
## Building and Analyzing Your First EDM
## Programming Against the Conceptual Model
## AutoLotDAL Version Four, Now with Entities
### The Role of Navigation Properties
### Using Navigation Properties within LINQ to Entity Queries
### Invoking a Stored Procedure
## Data Binding Entities to Windows Forms GUIs
### Adding the Data-Binding Code
## Going Forward with .NET Data-Access APIs
## Summary
___
# 24. Introducing LINQ to XML
## A Tale of Two XML APIs
### LINQ to XML As a Better DOM
### VB Literal Syntax As a Better LINQ to XML
## Members of the System.Xml.Linq Namespace
### The LINQ to XML Axis Methods
### The Oddness of XName (and XNamespace)
## Working with XElement and XDocument
### Generating Documents from Arrays and Containers
### Loading and Parsing XML Content
## Manipulating an In-Memory XML Document
### Building the UI of the LINQ to XML App
### Import the Inventory.xml File
### Defining a LINQ to XML Helper Class
### Attaching the UI to Your Helper Class
## Summary
___
# 25. Introducing Windows Communication Foundation
## A Potpourri of Distributed Computing APIs
### The Role of DCOM
### The Role of COM+/Enterprise Services
### The Role of MSMQ
### The Role of .NET Remoting
### The Role of XML Web Services
## The Role of WCF
### An Overview of WCF Features
### An Overview of Service-Oriented Architecture
### WCF: The Bottom Line
## Investigating the Core WCF Assemblies
## The Visual Studio WCF Project Templates
### The WCF Service Web Site Project Template
## The Basic Composition of a WCF Application
## The ABCs of WCF
### Understanding WCF Contracts
### Understanding WCF Bindings
### Understanding WCF Addresses
## Building a WCF Service
### The [ServiceContract] Attribute
### The [OperationContract] Attribute
### Service Types As Operational Contracts
## Hosting the WCF Service
### Establishing the ABCs Within an App.config File
### Coding Against the ServiceHost Type
### Specifying Base Addresses
### Details of the ServiceHost Type
### Details of the <system.serviceModel> Element
### Enabling Metadata Exchange
## Building the WCF Client Application
### Generating Proxy Code Using svcutil.exe
### Generating Proxy Code Using Visual Studio
### Configuring a TCP-Based Binding
## Simplifying Configuration Settings
### Leveraging Default Endpoints
### Exposing a Single WCF Service Using Multiple Bindings
### Changing Settings for a WCF Binding
### Leveraging the Default MEX Behavior Configuration
### Refreshing the Client Proxy and Selecting the Binding
## Using the WCF Service Library Project Template
### Building a Simple Math Service
### Testing the WCF Service with WcfTestClient.exe
### Altering Configuration Files Using SvcConfigEditor.exe
## Hosting the WCF Service Within a Windows Service
### Specifying the ABCs in Code
### Enabling MEX
### Creating a Windows Service Installer
### Installing the Windows Service
## Invoking a Service Asynchronously from the Client
## Designing WCF Data Contracts
### Using the Web-Centric WCF Service Project Template
### Implementing the Service Contract
### The Role of the *.svc File
### Examining the Web.config File
### Testing the Service
## Summary
___
# 26. Introducing Windows Workflow Foundation
## Defining a Business Process
### The Role of WF
## Building a Simple Workflow
## The Workflow Runtime
### Hosting a Workflow Using WorkflowInvoker
### Hosting a Workflow Using WorkflowApplication
### Recap of Your First Workflow
## Examining the Workflow Activities
### Control Flow Activities
### Flowchart Activities
### Messaging Activities
### The State Machine Activities
### The Runtime and Primitives Activities
### The Transaction Activities
### The Collection and Error Handling Activities
## Building a Flowchart Workflow
### Connecting Activities in a Flowchart
### Working with the InvokeMethod Activity
### Defining Workflow-Wide Variables
### Working with the FlowDecision Activity
### Working with the TerminateWorkflow Activity
### Building the “True” Condition
### Working with the ForEach<T> Activity
### Completing the Application
### Reflecting on What We Have Done
## Building a Sequence Workflow (in a Dedicated DLL)
### Defining the Initial Project
### Importing Assemblies and Namespaces
### Defining the Workflow Arguments
### Defining Workflow Variables
### Working with the Assign Activity
### Working with the If and Switch Activities
### Building a Custom Code Activity
## Consuming the Workflow Library
### Retrieving the Workflow Output Argument
## Summary
___
# 27. Introducing Windows Presentation Foundation and XAML
## The Motivation Behind WPF
### Unifying Diverse APIs
### Providing a Separation of Concerns via XAML
### Providing an Optimized Rendering Model
### Simplifying Complex UI Programming
## The Various Flavors of WPF
### Traditional Desktop Applications
### Navigation-Based WPF Applications
### XBAP Applications
### The WPF/Silverlight Relationship
## Investigating the WPF Assemblies
### The Role of the Application Class
### The Role of the Window Class
## Building a WPF Application Without XAML
### Creating a Strongly Typed Window
### Creating a Simple User Interface
### Interacting with Application-Level Data
### Handling the Closing of a Window Object
### Intercepting Mouse Events
### Intercepting Keyboard Events
## Building a WPF Application Using Only XAML
### Defining a Window Object in XAML
### Defining the Application Object in XAML
### Processing the XAML Files Using msbuild.exe
## Transforming Markup into a .NET Assembly
### Mapping the Window XAML Markup to C# Code
### The Role of BAML
### Mapping the Application XAML Markup to C# Code
### XAML-to-Assembly Process Summary
## Understanding the Syntax of WPF XAML
### Introducing Kaxaml
### XAML XML Namespaces and XAML “Keywords”
### Controlling Class and Member Variable Visibility
### XAML Elements, XAML Attributes, and Type Converters
### Understanding XAML Property-Element Syntax
### Understanding XAML Attached Properties
### Understanding XAML Markup Extensions
## Building a WPF Application Using Code-Behind Files
### Adding a Code File for the MainWindow Class
### Adding a Code File for the MyApp Class
### Processing the Code Files with msbuild.exe
## Building WPF Applications Using Visual Studio
### The WPF Project Templates
### The Toolbox and XAML Designer/Editor
### Setting Properties Using the Properties Window
### Handling Events Using the Properties Window
### Handling Events in the XAML Editor
### The Document Outline Window
### Viewing the AutoGenerated Code Files
## Building a Custom XAML Editor with Visual Studio
### Designing the GUI of Our Window
### Implementing the Loaded Event
### Implementing the Button’s Click Event
### Implementing the Closed Event
### Testing Your Application
### Exploring the WPF Documentation
## Summary
___
# 28. Programming with WPF Controls
## A Survey of the Core WPF Controls
### The WPF Ink Controls
### The WPF Document Controls
### WPF Common Dialog Boxes
### The Details Are in the Documentation
## A Brief Review of the Visual Studio WPF Designer
### Working with WPF Controls Using Visual Studio
### Working with the Document Outline Editor
## Controlling Content Layout Using Panels
### Positioning Content Within Canvas Panels
### Positioning Content Within WrapPanel Panels
### Positioning Content Within StackPanel Panels
### Positioning Content Within Grid Panels
### Positioning Content Within DockPanel Panels
### Enabling Scrolling for Panel Types
### Configuring Panels Using the Visual Studio Designers
## Building a Window’s Frame Using Nested Panels
### Building the Menu System
### Building the ToolBar
### Building the StatusBar
### Finalizing the UI Design
### Implementing the MouseEnter/MouseLeave Event Handlers
### Implementing the Spell Checking Logic
## Understanding WPF Commands
### The Intrinsic Command Objects
### Connecting Commands to the Command Property
### Connecting Commands to Arbitrary Actions
### Working with the Open and Save Commands
## A Deeper Look at WPF APIs and Controls
### Working with the TabControl
## Building the Ink API Tab
### Designing the ToolBar
### The RadioButton Control
### Handling Events for the Ink API Tab
### The InkCanvas Control
### The ComboBox Control
### Saving, Loading, and Clearing InkCanvas Data
## Introducing the Documents API
### Block Elements and Inline Elements
### Document Layout Managers
## Building the Documents Tab
### Populating a FlowDocument Using Code
### Enabling Annotations and Sticky Notes
### Saving and Loading a Flow Document
## Introducing the WPF Data-Binding Model
### Building the Data Binding Tab
### Establishing Data Bindings Using Visual Studio
### The DataContext Property
### Data Conversion Using IValueConverter
### Establishing Data Bindings in Code
### Building the DataGrid Tab
## Summary
___
# 29. WPF Graphics Rendering Services
## Understanding WPF’s Graphical Rendering Services
### WPF Graphical Rendering Options
## Rendering Graphical Data Using Shapes
### Adding Rectangles, Ellipses, and Lines to a Canvas
### Removing Rectangles, Ellipses, and Lines from a Canvas
### Working with Polylines and Polygons
### Working with Paths
## WPF Brushes and Pens
### Configuring Brushes Using Visual Studio
### Configuring Brushes in Code
### Configuring Pens
## Applying Graphical Transformations
### A First Look at Transformations
### Transforming Our Canvas Data
## Working with the Visual Studio Transform Editor
### Building the Initial Layout
### Applying Transformations at Design Time
### Transforming the Canvas in Code
## Rendering Graphical Data Using Drawings and Geometries
### Building a DrawingBrush Using Geometries
### Painting with the DrawingBrush
### Containing Drawing Types in a DrawingImage
## The Role of Expression Design
### Exporting a Sample Design File As XAML
### Importing the Graphical Data into a WPF Project
### Interacting with the Bear
## Rendering Graphical Data Using the Visual Layer
## Summary
___
# 30. WPF Resources, Animations, and Styles
## Understanding the WPF Resource System
### Working with Binary Resources
## Working with Object (Logical) Resources
### The Role of the Resources Property
### Defining Window-Wide Resources
### The Markup Extension
### The {DynamicResource} Markup Extension
### Application-Level Resources
### Defining Merged Resource Dictionaries
### Defining a Resource-Only Assembly
## Understanding WPF’s Animation Services
### The Role of the Animation Class Types
### The To, From, and By Properties
### The Role of the Timeline Base Class
### Authoring an Animation in C# Code
### Controlling the Pace of an Animation
### Reversing and Looping an Animation
## Authoring Animations in XAML
### The Role of Storyboards
### The Role of Event Triggers
### Animation Using Discrete Key Frames
## Understanding the Role of WPF Styles
### Defining and Applying a Style
### Overriding Style Settings
### Automatically Applying a Style with TargetType
### Subclassing Existing Styles
### The Role of Unnamed Styles
### Defining Styles with Triggers
### Defining Styles with Multiple Triggers
### Animated Styles
### Assigning Styles Programmatically
## Summary
___
# 31. Dependency Properties, Routed Events, and Templates
## Understanding the Role of Dependency Properties
### Examining an Existing Dependency Property
### Important Notes Regarding CLR Property Wrappers
## Building a Custom Dependency Property
### Adding a Data Validation Routine
### Responding to the Property Change
## Understanding Routed Events
### The Role of Routed Bubbling Events
### Continuing or Halting Bubbling
### The Role of Routed Tunneling Events
## Logical Trees, Visual Trees, and Default Templates
### Programmatically Inspecting a Logical Tree
### Programmatically Inspecting a Visual Tree
### Programmatically Inspecting a Control’s Default Template
## Building a Control Template with the Trigger Framework
### Templates As Resources
### Incorporating Visual Cues Using Triggers
### The Role of the {TemplateBinding} Markup Extension
### The Role of ContentPresenter
### Incorporating Templates into Styles
## Summary
___
# 32. Introducing ASP.NET Web Forms
## The Role of HTTP
### The HTTP Request/Response Cycle
### HTTP Is a Stateless Protocol
## Understanding Web Applications and Web Servers
### The Role of IIS Virtual Directories
### The ASP.NET Development Web Server
## The Role of HTML
### HTML Document Structure
### The Role of an HTML Form
### The Visual Studio HTML Designer Tools
### Building an HTML Form
## The Role of Client-Side Scripting
### A Client-Side Scripting Example
## Posting Back to the Web Server
### Postbacks Under ASP.NET
## An Overview of the ASP.NET API
### Major Features of ASP.NET 2.0 and Higher
### Major Features of ASP.NET 3.5 (and .NET 3.5 SP1) and Higher
### Major Features of ASP.NET 4.0 and 4.5
## Building a Single-File ASP.NET Web Page
### Referencing AutoLotDAL.dll
### Designing the UI
### Adding the Data Access Logic
### The Role of ASP.NET Directives
### Analyzing the “Script” Block
### Analyzing the ASP.NET Control Declarations
## Building an ASP.NET Web Page Using Code Files
### Referencing the AutoLotDAL.dll Assembly
### Updating the Code File
### Debugging and Tracing ASP.NET Pages
## ASP.NET Web Sites vs. ASP.NET Web Applications
## The ASP.NET Web Site Directory Structure
### Referencing Assemblies
### The Role of the App_Code Folder
## The Inheritance Chain of the Page Type
## Interacting with the Incoming HTTP Request
### Obtaining Browser Statistics
### Access to Incoming Form Data
### The IsPostBack Property
## Interacting with the Outgoing HTTP Response
### Emitting HTML Content
### Redirecting Users
## The Life Cycle of an ASP.NET Web Page
### The Role of the AutoEventWireup Attribute
### The Error Event
## The Role of the web.config File
### The ASP.NET Web Site Administration Utility
## Summary
___
# 33. ASP.NET Web Controls, Master Pages, and Themes
## Understanding the Nature of Web Controls
### Understanding Server-Side Event Handling
### The AutoPostBack Property
## The Control and WebControl Base Classes
### Enumerating Contained Controls
### Dynamically Adding and Removing Controls
### Interacting with Dynamically Created Controls
### Functionality of the WebControl Base Class
## Major Categories of ASP.NET Web Controls
### A Brief Word Regarding System.Web.UI.HtmlControls
### Web Control Documentation
## Building the ASP.NET Cars Web Site
### Working with ASP.NET Master Pages
### Defining the Default Content Page
### Designing the Inventory Content Page
### Designing the Build-a-Car Content Page
## The Role of the Validation Controls
### Enabling Client-Side JavaScript Validation Support
### The RequiredFieldValidator
### The RegularExpressionValidator
### The RangeValidator
### The CompareValidator
### Creating Validation Summaries
### Defining Validation Groups
## Working with Themes
### Understanding *.skin Files
### Applying Site-Wide Themes
### Applying Themes at the Page Level
### The SkinID Property
### Assigning Themes Programmatically
## Summary
___
# 34. ASP.NET State Management Techniques
## The Issue of State
## ASP.NET State Management Techniques
## Understanding the Role of ASP.NET View State
### Demonstrating View State
### Adding Custom View State Data
## The Role of the Global.asax File
### The Global Last-Chance Exception Event Handler
### The HttpApplication Base Class
## Understanding the Application/Session Distinction
### Maintaining Application-Level State Data
### Modifying Application Data
### Handling Web Application Shutdown
## Working with the Application Cache
### Fun with Data Caching
### Modifying the *.aspx File
## Maintaining Session Data
### Additional Members of HttpSessionState
## Understanding Cookies
### Creating Cookies
### Reading Incoming Cookie Data
## The Role of the <sessionState> Element
### Storing Session Data in the ASP.NET Session State Server
### Storing Session Data in a Dedicated Database
## Introducing the ASP.NET Profile API
### The ASPNETDB.mdf Database
### Defining a User Profile Within web.config
### Accessing Profile Data Programmatically
### Grouping Profile Data and Persisting Custom Objects
## Summary
