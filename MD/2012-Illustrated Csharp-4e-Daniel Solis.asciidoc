[[_0_]]
= Illustrated Csharp 4e
Joy <arbago@gmail.com>
v1.0, 2015-06-14
:icons: font
:sectanchors:
:imagesdir: images
:homepage: http://arbago.com
:toc: macro

toc::[]

[preface]
== 책

Illustrated Csharp 4e, Daniel Solis, 2012

[preface]
== 머릿말

[[_1_]]
== 1. C# and the .NET Framework

[[_1_1_]]
=== Before .NET

[[_1_1_1_]]
==== Windows Programming in the Late 1990s

[W] afterthought (ăf′tər-thôt′)::
-   afterthought - thinking again about a choice previously madeafterthought - thinking again about a choice previously made; "he had second thoughts about his purchase"
* =rethink, second thought, reconsideration
* change of mind, flip-flop, turnabout, turnaround, reversal - a decision to reverse an earlier decision
** At the time, programming for the Web was an *afterthought* and seemed very different from coding for the desktop.
- afterthought - an addition that was not included in the original planafterthought - an addition that was not included in the original plan; "the garage was an afterthought"
* addition, add-on, improver - a component that is added to something to improve it; "the addition of a bathroom was a major improvement"; "the addition of cinnamon improved the flavor"

[[_1_1_2_]]
==== Goals for the Next-Generation Platform Services

To meet this need, Microsoft set out to develop::
* a code execution environment
** Security: safer execution environment
** Multiple Platforms: from servers and desktop machines to PDSs and cell phones
** Industry standards: XML, HTTP, SOAP, JSON, and WSDL
** Performance
* a code development environment
** Object-Oriented Development Environment
** Consistent Programming Experience
** Communication Using Industry Standards
** Simplified Deployment
** Language Independence
** Interoperability

[[_1_2_]]
=== Enter Microsoft .NET

#see pound#

[[_1_2_3_]]
==== Components of the .NET Framework

* CLR (Common Language Runtime): the execution environment
** Memory management and garbage collection
** Code safety verification
** Code execution, thread management, and exception handling
* Programming Tools:
* BCL (Base Class Library

[[_1_2_4_]]
==== An Improved Programming Environment

[[_1_2_5_]]
===== Object-Oriented Development Environment

[[_1_2_6_]]
===== Automatic Garbage Collection

[[_1_2_7_]]
===== Interoperability

language-agnostic

platform invoke (P/Invoke)::
*it allows code written for .NET to call and use code not written for .NET +
*it can use raw C functions imported from standard Win32 DLLs, such as Windows APIs

[[_1_2_8_]]
===== No COM Required

. no use any more
* The IUnknown interface
* Type libraries -> bundled with the code
* Manual reference counting -> GC
* HRESULT -> exceptions
* The registry -> global assembly cache

[[_1_2_9_]]
===== Simplified Deployment

* no registry, just copy to the target machine
* side-by-side execution: different versions of a DLL

[[_1_2_10_]]
===== Type Safety

[[_1_2_11_]]
===== The Base Class Library

* BCL: Base Class Library
* FCL: Framework Class Library

.BCL (or FCL)
* General base classes
* Collection classes
* Threading and synchronization classes
* XML classes

[[_1_3_]]
=== Compiling to the Common Intermediate Language

[[_1_4_]]
=== Compiling to Native Code and Execution

assembly:: output file
* an executable or a DLL
* CIL (Common Intermediate Language)
* type information
* security information

.other names of CIL
* IL: Intermediate Language
* MSIL: Microsoft Intermediate Language

.compiling
* checks the security
* allocates memory
* JIT compiler to make native code

.JIT compiler
* only as it's needed
* cached
* code that isn't called isn't compied to native code +
and code that is called need only be compiled once

.CLR
* manages as the native code runs
* managed code: .NET Framework
* unmanaged code: Win32 C and C++ DLLs

.Ngen (Native Image Generator)
* takes an assembly and produces native code for the current processor

[[_1_4_12_]]
==== Overview of Compilation and Execution

[[_1_5_]]
=== The Common Language Runtime

[[_1_6_]]
=== The Common Language Infrastructure (CLI)

ECMA: European Computer Manufacturers Association

[[_1_6_13_]]
==== Important Parts of the CLI

* CTS: Common Type System
* CLS: Common Language Specification

[[_1_6_14_]]
===== The Common Type System

[[_1_6_15_]]
===== The Common Language Specification

[[_1_7_]]
=== Review of the Acronyms

.Assembly
* CIL
* IL
* MSIL

.CLI
* CTS
* CLS

.CLR
* GC
* JIT
* BCL

[[_1_8_]]
=== The Evolution of C#

.Evolution of C#
* 1.0: C#
* 2.0: Generics
* 3.0: LINQ
* 4.0: Named and Optional Parameters
* 5.0: Async

[[_2_]]
== 2. Overview of C# Programming

[[_2_1_]]
=== A Simple C# Program

[[_2_1_16_]]
==== More About SimpleProgram

[[_2_2_]]
=== Identifiers

[[_2_3_]]
=== Keywords

[[_2_4_]]
=== Main: The Starting Point of a Program

[[_2_5_]]
=== Whitespace

[[_2_6_]]
=== Statements

[[_2_6_17_]]
==== Blocks

[[_2_7_]]
=== Text Output from a Program

[[_2_7_18_]]
==== Write

[[_2_7_19_]]
==== WriteLine

[[_2_7_20_]]
==== The Format String

- parameters are separated by commas
- format string: the first parameter
- substitution markers
- substitution values

[[_2_7_21_]]
==== Multiple Markers and Values

- any number of markers
- any number of values
- in any order
- any number of times

- not produce a compile error but a runtime error (called an exception)

[[_2_7_22_]]
==== Formatting Numeric Strings

format specifier: { index, alignment :format }

[[_2_7_23_]]
===== The Alignment Specifier

- minimum width: minimum number of character to use for the field
- the sign: represents either right or left alignment

[W] The format items are between two vertical bars, `just so that` in the output you can see the limits of the string on each side.

padded with spaces, or the alignment specifier is ignored

[[_2_7_24_]]
===== The Format Field

.the colon character
- with no intervening spaces

.format specifier
- a single alphabetic character
- nine built-in character formats
- the case is *significant* for some specifiers but not for others

.precision specifier
- one or two digits

[[_2_7_25_]]
===== Standard Numeric Format Specifiers

.nine standard numeric format specifiers
|===
|Name            | Character       | Meaning
|Currency        | C, c            | the number of decimal places
|Decimal         | D, d            | padded with 0s on the left
|Fixed-point     | F, f            | the number of decimal places
|General         | G, g            | default
|Hexadecimal     | X, x            | padded with 0s on the left. case sensitive
|Number          | N, n            | comma or period separators. the number of decimal places
|Percent         | P, p            | multipled by 100. the number of decimal places
|Round-trip      | R, r            | Parse method. Precision specifier is ignored.
|Scientific      | E, e            | mantissa, exponent. The exponent is preceded by the letter E. case sensitive
|===

[[_2_8_]]
=== Comments: Annotating the Code

[[_2_8_26_]]
==== More About Comments

[[_2_8_27_]]
==== Documentation Comments

- XML text
- three contiguous slashes

[[_2_8_28_]]
==== Summary of Comment Types

- Single-line: //
- Delimited: /* */
- Documentation: ///

[[_3_]]
== 3. Types, Storage, and Variables

[[_3_1_]]
=== A C# Program Is a Set of Type Declarations

[[_3_2_]]
=== A Type Is a Template

[[_3_3_]]
=== Instantiating a Type

[[_3_4_]]
=== Data Members and Function Members

[[_3_4_29_]]
==== Types of Members

[[_3_5_]]
=== Predefined Types

[[_3_5_30_]]
==== More About the Predefined Types

[[_3_6_]]
=== User-Defined Types

[[_3_7_]]
=== The Stack and the Heap

[[_3_7_31_]]
==== The Stack

[[_3_7_32_]]
===== Facts About Stacks

[[_3_7_33_]]
==== The Heap

[[_3_8_]]
=== Value Types and Reference Types

[[_3_8_34_]]
==== Storing Members of a Reference Type Object

[[_3_8_35_]]
==== Categorizing the C# Types

[[_3_9_]]
=== Variables

[[_3_9_36_]]
==== Variable Declarations

[[_3_9_37_]]
===== Variable Initializers

[[_3_9_38_]]
===== Automatic Initialization

[[_3_9_39_]]
==== Multiple-Variable Declarations

[[_3_9_40_]]
==== Using the Value of a Variable

[[_3_10_]]
=== Static Typing and the dynamic Keyword

[[_3_11_]]
=== Nullable Types

[[_4_]]
== 4. Classes: The Basics

[[_4_1_]]
=== Overview of Classes

[[_4_1_41_]]
==== A Class Is an Active Data Structure

[[_4_2_]]
=== Programs and Classes: A Quick Example

[[_4_3_]]
=== Declaring a Class

Class members can be declared in any order inside the class body. This means it's perfectly fine for the declaration of a member to refer to another member that is not yet defined until further down in the class declaration.

[[_4_4_]]
=== Class Members

[[_4_4_42_]]
==== Fields

Unlike C and C++, in C# there are **_no global variables_** declared outside of a type.

[[_4_4_43_]]
===== Explicit and Implicit Field Initialization

The default value for each type is _**0**_, and false for _**bool**_. The default for reference types is _**null**_.

[[_4_4_44_]]
===== Declarations with Multiple Fields

[[_4_4_45_]]
==== Methods

Unlike C and C++, in C# there are _**no global functions**_ declared outside of type declaration. Also unlike C and C++, in C# there is no **"default"** return type for a method. All methods must include a return type of list it as void.

[[_4_5_]]
=== Creating Variables and Instances of a Class

[[_4_6_]]
=== Allocating Memory for the Data

[[_4_6_46_]]
==== Combining the Steps

[[_4_7_]]
=== Instance Members

[[_4_8_]]
=== Access Modifiers

[[_4_8_47_]]
==== Private and Public Access

[[_4_8_48_]]
===== Depicting Public and Private Access

[[_4_8_49_]]
===== Example of Member Access

[[_4_9_]]
=== Accessing Members from Inside the Class

[[_4_10_]]
=== Accessing Members from Outside the Class

[[_4_11_]]
=== Putting It All Together

[[_5_]]
== 5. Methods

[[_5_1_]]
=== The Structure of a Method

[[_5_2_]]
=== Code Execution in the Method Body

[[_5_3_]]
=== Local Variables

[W] Blocks can be nested `to any level`.

In C# you cannot declare another local variable with the same name within the scope of the first name, regardless of the level of nesting.

[[_5_3_50_]]
==== Type Inference and the var Keyword

[[_5_3_51_]]
==== Local Variables Inside Nested Blocks

[[_5_4_]]
=== Local Constants

The mandatory initializer. The initializer value must be determinable at compile time and is usually one of the predefined simple types or an expression made up of them. It can also be _**null reference**_, but it cannot be a reference to an object, because references to objects are determined at run time.

[[_5_5_]]
=== Flow of Control

Methods contain most of the code that _**comprise**_ a program.

[[_5_6_]]
=== Method Invocations

[[_5_7_]]
=== Return Values

[[_5_8_]]
=== The Return Statement and Void Methods

[[_5_9_]]
=== Parameters

[[_5_9_52_]]
==== Formal Parameters

[[_5_9_53_]]
==== Actual Parameters

[[_5_9_54_]]
===== An Example of Methods with Positional Parameters

[[_5_10_]]
=== Value Parameters

[[_5_11_]]
=== Reference Parameters

[[_5_12_]]
=== Reference Types As Value and Reference Parameters

[[_5_13_]]
=== Output Parameters

[W] Inside the method, `every possible path through the code` must assign a value to every output parameter before the method can exit.

[[_5_14_]]
=== Parameter Arrays

Parameter arrays are different `in that` they allow *zero or more actual parameter* of a particular type for a particular formal parameter.

- only one parameter array
- the last parameter in the list
- of the same type

- *params* modifier before the data type
- empty square brackets

[[_5_14_55_]]
==== Method Invocation

- A comma-separated list: ListInts(10,20,30);
- A one-dimensional array: int[] intArray = {10,20,30}; ListInts(intArray);

Do not use the **params** modifier in the *invocation*.

The usage of the modifier in parameter arrays doesn't fit the pattern of the other parameter types.

[[_5_14_56_]]
===== Expanded Form

It takes the list of actual parameters and uses them to *create and initialize an array* in the heap.

the values of the actual parameters are **copied** to the array.

[[_5_14_57_]]
==== Arrays As Actual Parameters

[[_5_15_]]
=== Summary of Parameter Types

[[_5_16_]]
=== Method Overloading

[[_5_17_]]
=== Named Parameters

[[_5_18_]]
=== Optional Parameters

[[_5_19_]]
=== Stack Frames

[[_5_20_]]
=== Recursion

[[_6_]]
== 6. More About Classes

[[_6_1_]]
=== Class Members

[[_6_2_]]
=== Order of Member Modifiers

[[_6_3_]]
=== Instance Class Members

[[_6_4_]]
=== Static Fields

[[_6_5_]]
=== Accessing Static Members from Outside the Class

[[_6_5_58_]]
==== Example of a Static Field

[[_6_5_59_]]
==== Lifetimes of Static Members

[[_6_6_]]
=== Static Function Members

[[_6_7_]]
=== Other Static Class Member Types

[[_6_8_]]
=== Member Constants

[[_6_9_]]
=== Constants Are Like Statics

[[_6_10_]]
=== Properties

[W] Using a property appears `very much like` writing to, or reading from, a field.

.property as a function
* Unlike a field, however, a property is a function member, hence:
** It does not necessarily allocate memory for data storage.
** It executes code.

[[_6_10_60_]]
==== Property Declarations and Accessors

[[_6_10_61_]]
==== A Property Example

Notice that the property itself doesn't have any storage.

[[_6_10_62_]]
==== Using a Property

The accessors are called implicitly.

You cannot explicitly call the accessors.

[[_6_10_63_]]
==== Properties and Associated Fields

A common practice is to encapsulate a field in a class by declaring the field 'private' and declaring a 'public' property to give controlled access to the field from outside the class. The field associated with a property is called the 'backing field' or 'backing store'.

One convention is to use the same string for both names but use 'camel casing' for the field and 'Pascal casing' for the property'.

Another convention is to use Pascal casing for the property, and then for the field, use the camel version of the same identifier, with an underscore in front.

[[_6_10_64_]]
==== Performing Other Calculations

[[_6_10_65_]]
==== Read-Only and Write-Only Properties

[[_6_10_66_]]
==== Properties vs. Public Fields

.properties are preferred over public fields
* process the input and output
* read-only or write-only properties
* The semantics of a compiled variable and a compiled property are different.

[[_6_10_67_]]
==== An Example of a Computed, Read-Only Property

[W] hypotenuse  (hī-pŏt′n-o͞os′, -yo͞os′)  also hy·poth·e·nuse (-pŏth′ə-no͞os′, -nyo͞os′)

.The side of a right triangle opposite the right angle.

[1565–75; < Latin hypotēnūsa < Greek hypoteínousa (grámmē) **subtending (line)**, feminine present participle of hypoteínein to **subtend** =hypo- hypo- + teínein to stretch (see thin)]

.hypotenuse - the side of a right triangle opposite the right angle
- <>right triangle, right-angled triangle - a triangle with one right angle
- <>flank - a subfigure consisting of a side of something

[[_6_10_68_]]
==== Automatically Implemented Properties

Because properties are so often associated iwth backing fields, C# provides 'automatically implemented properties', or 'auto-implemented properties', which allow you to just declare the property, without declaring a backing field. The compiler creates a hidden backing field for you and automatically hooks up the get and set accessors to it.

.auto properties
* You do not declare the backing field
* You cannot supply the bodies of the accessors
* read-only or write-only auto-implemented properties are not allowed

Besides being convenient, auto-implemented properties allow you to easily insert a property where you might be tempted to declare a public field.

[[_6_10_69_]]
==== Static Properties

They cannot access instance members of a class - although they can be accessed by them

[[_6_11_]]
=== Instance Constructors

[[_6_11_70_]]
==== Constructors with Parameters

[[_6_11_71_]]
==== Default Constructors

[[_6_12_]]
=== Static Constructors

[[_6_12_72_]]
==== Example of a Static Constructor

[[_6_13_]]
=== Object Initializers

[[_6_14_]]
=== Destructors

[[_6_15_]]
=== The readonly Modifier

[[_6_16_]]
=== The this Keyword

[[_6_17_]]
=== Indexers

[[_6_17_73_]]
==== What Is an Indexer?

[[_6_17_74_]]
==== Indexers and Properties

[[_6_17_75_]]
==== Declaring an Indexer

[[_6_17_76_]]
==== The Indexer set Accessor

[[_6_17_77_]]
==== The Indexer get Accessor

[[_6_17_78_]]
==== More About Indexers

[[_6_17_79_]]
==== Declaring the Indexer for the Employee Example

[[_6_17_80_]]
==== Another Indexer Example

[[_6_17_81_]]
==== Indexer Overloading

[[_6_18_]]
=== Access Modifiers on Accessors

[W] By default, `both a member's accessors` have the same access level as the member itself. That is, if a property has an access level of public, then `both its accessors` have that same access level. The same is true of indexers.

[[_6_19_]]
=== Partial Classes and Partial Types

[[_6_20_]]
=== Partial Methods

[[_7_]]
== 7. Classes and Inheritance

[[_7_1_]]
=== Class Inheritance

[[_7_2_]]
=== Accessing the Inherited Members

[[_7_3_]]
=== All Classes Are Derived from Class object

[[_7_4_]]
=== Masking Members of a Base Class

A derived class 'cannot delete any of the members' it has inherited; it can, however, 'mask a base class member' with a member of the same name.

.masking
* data member
** same type, same name
* function member
** same signature (name, parameter list)
* [big blue yellow-background underline]*new* modifier (without it, the compiler will warn you)
* static members can also be masked

[[_7_5_]]
=== Base Access

If your derived class absolutely must #access a hidden inherited member#, you can access it by using a _base access_ expression.

[W] Generally there are mmore elegant designs-`but the feature is there` if there's a situation +where+ nothing else will do.

[[_7_6_]]
=== Using References to a Base Class

An instance of a derived class consists of an instance of the base class plus the additional members of the derived class.

If you have a reference to a derived class object, you can get a reference to just the base class part of the object by [big blue yellow-background underline]*casting* the reference to the type of the base class by using the 'cast operator'.

The reference to the base class part 'cannot "see" the rest of the derived class object', because it's "looking" at it through a reference to the base type.

[[_7_6_82_]]
==== Virtual and Override Methods

'Virtual methods' allow a reference to the base class to access "up into" the derived class.

.virtual
* same signature and return type
* base class has 'virtual methods'
* derived class has 'override methods'

.virtual
* the same accessibility
* static methods can not be overridden
* Methods, properties, indexers, events

[[_7_6_83_]]
==== Overriding a Method Marked override

[W] Overriding methods can occur `between any levels of inheritance`.

* passed up the derivation hierarchy for execution to the 'most-derived version' of the method 'marked as override'

[[_7_6_84_]]
===== Case 1: Declaring Print with override

override both the less-derived versions

regardless of whether Print is called through the derived class or the base class, the method in the most-derived class is called

[[_7_6_85_]]
===== Case 2: Declaring Print with new

[[_7_6_86_]]
==== Overriding Other Member Types

[[_7_7_]]
=== Constructor Execution

[[_7_7_87_]]
==== Constructor Initializers

[[_7_7_88_]]
==== Class Access Modifiers

[[_7_8_]]
=== Inheritance Between Assemblies

[[_7_9_]]
=== Member Access Modifiers

[[_7_9_89_]]
==== Regions Accessing a Member

[[_7_9_90_]]
==== Public Member Accessibility

[[_7_9_91_]]
==== Private Member Accessibility

[[_7_9_92_]]
==== Protected Member Accessibility

[[_7_9_93_]]
==== Internal Member Accessibility

[[_7_9_94_]]
==== Protected Internal Member Accessibility

[[_7_9_95_]]
==== Summary of Member Access Modifiers

[[_7_10_]]
=== Abstract Members

[[_7_11_]]
=== Abstract Classes

[[_7_11_96_]]
==== Example of an Abstract Class and an Abstract Method

[[_7_11_97_]]
==== Another Example of an Abstract Class

[[_7_12_]]
=== Sealed Classes

[[_7_13_]]
=== Static Classes

A static class is a class `where` all the members are static. Static classes are used to group data and functions that are not affected by instance data.

- a static constructor
- implicitly sealed

[[_7_14_]]
=== Extension Methods

[[_7_15_]]
=== Naming Conventions

[W] Writing programs requires `coming up with` lots of names; names for classes, variables, methods, properties, and lots of things I haven't covered yet.

[[_8_]]
== 8. Expressions and Operators

[[_8_1_]]
=== Expressions

[[_8_2_]]
=== Literals

[[_8_2_98_]]
==== Integer Literals

[[_8_2_99_]]
==== Real Literals

[[_8_2_100_]]
==== Character Literals

[[_8_2_101_]]
==== String Literals

[[_8_3_]]
=== Order of Evaluation

[W] `You know from your grade school days` that in the preceding example, the multiplication must be performed before the addition because multiplication has a higher precedence than addition. `But unlike grade-school days`, where you had four operators and two levels of precedence, `things are a bit more complex with` C#, which has more than 45 operators and 14 levels of precedence.

[[_8_3_102_]]
==== Precedence

[[_8_3_103_]]
==== Associativity

[[_8_4_]]
=== Simple Arithmetic Operators

[[_8_5_]]
=== The Remainder Operator

[[_8_6_]]
=== Relational and Equality Comparison Operators

[[_8_6_104_]]
==== Comparison and Equality Operations

[[_8_7_]]
=== Increment and Decrement Operators

[[_8_8_]]
=== Conditional Logical Operators

[[_8_9_]]
=== Logical Operators

[[_8_10_]]
=== Shift Operators

[[_8_11_]]
=== Assignment Operators

[[_8_11_105_]]
==== Compound Assignment

[[_8_12_]]
=== The Conditional Operator

[[_8_13_]]
=== Unary Arithmetic Operators

[[_8_14_]]
=== User-Defined Type Conversions

[[_8_14_106_]]
==== Explicit Conversion and the Cast Operator

[[_8_15_]]
=== Operator Overloading

[[_8_15_107_]]
==== Restrictions on Operator Overloading

[[_8_15_108_]]
==== Example of Operator Overloading

[[_8_16_]]
=== The typeof Operator

[[_8_17_]]
=== Other Operators

[[_9_]]
== 9. Statements

[[_9_1_]]
=== What Are Statements?

A *statement* is a source code instruction describing a type or telling the program to perform an action.

- Declaration statements
- Embedded statements: Statements that perform actions or manage flow of control
- Labeled statements

Embedded statements

- Simple statement
- block
- empty statement: You can use an empty statement at any position where the syntax of the language requires an embedded statement but your program logic does not require any action.

A block counts syntactically as a single embedded statement. Anywhere that an embedded statement is required syntactically, you can use a block.

[[_9_2_]]
=== Expression Statements

[[_9_3_]]
=== Flow-of-Control Statements

Unlike C and C++, in C# test expressions must return a value of type _bool_. Numbers do not have a Boolean interpretation in C#.

[[_9_4_]]
=== The if Statement

[[_9_5_]]
=== The if...else Statement

[[_9_6_]]
=== The while Loop

[[_9_7_]]
=== The do Loop

[[_9_8_]]
=== The for Loop

[[_9_8_109_]]
==== The Scope of Variables in a for Statement

[[_9_8_110_]]
==== Multiple Expressions in the Initializer and Iteration Expression

[[_9_9_]]
=== The switch Statement

[[_9_9_111_]]
==== A Switch Example

[[_9_9_112_]]
==== More on the switch Statement

[[_9_9_113_]]
==== Switch Labels

[[_9_10_]]
=== Jump Statements

[[_9_11_]]
=== The break Statement

[[_9_12_]]
=== The continue Statement

[[_9_13_]]
=== Labeled Statements

[[_9_13_114_]]
==== Labels

[[_9_13_115_]]
==== The Scope of Labeled Statements

[[_9_14_]]
=== The goto Statement

[[_9_14_116_]]
==== The goto Statement Inside a switch Statement

[[_9_15_]]
=== The using Statement

[[_9_15_117_]]
==== Packaging the Use of a Resource

[[_9_15_118_]]
==== Example of the using Statement

[[_9_15_119_]]
==== Multiple Resources and Nesting

[[_9_15_120_]]
==== Another Form of the using Statement

[[_9_16_]]
=== Other Statements

[[_10_]]
== 10. Structs

[[_10_1_]]
=== What Are Structs?

[[_10_2_]]
=== Structs Are Value Types

[[_10_3_]]
=== Assigning to a Struct

[[_10_4_]]
=== Constructors and Destructors

[[_10_4_121_]]
==== Instance Constructors

[[_10_4_122_]]
==== Static Constructors

[[_10_4_123_]]
==== Summary of Constructors and Destructors

[[_10_5_]]
=== Field Initializers Are Not Allowed

[[_10_6_]]
=== Structs Are Sealed

[[_10_7_]]
=== Boxing and Unboxing

[[_10_8_]]
=== Structs As Return Values and Parameters

[[_10_9_]]
=== Additional Information About Structs

[[_11_]]
== 11. Enumerations

[[_11_1_]]
=== Enumerations

[[_11_1_124_]]
==== Setting the Underlying Type and Explicit Values

[[_11_1_125_]]
==== Implicit Member Numbering

[[_11_2_]]
=== Bit Flags

[[_11_2_126_]]
==== The Flags Attribute

[[_11_2_127_]]
==== Example Using Bit Flags

[[_11_3_]]
=== More About Enums

[[_12_]]
== 12. Arrays

[[_12_1_]]
=== Arrays

[[_12_1_128_]]
==== Definitions

[[_12_1_129_]]
==== Important Details

[[_12_2_]]
=== Types of Arrays

[[_12_3_]]
=== An Array As an Object

[[_12_4_]]
=== One-Dimensional and Rectangular Arrays

[[_12_4_130_]]
==== Declaring a One-Dimensional or Rectangular Array

[[_12_5_]]
=== Instantiating a One-Dimensional or Rectangular Array

[[_12_6_]]
=== Accessing Array Elements

[[_12_7_]]
=== Initializing an Array

[[_12_7_131_]]
==== Explicit Initialization of One-Dimensional Arrays

[[_12_7_132_]]
==== Explicit Initialization of Rectangular Arrays

[[_12_7_133_]]
==== Syntax Points for Initializing Rectangular Arrays

[[_12_7_134_]]
==== Shortcut Syntax

[[_12_7_135_]]
==== Implicitly Typed Arrays

[[_12_7_136_]]
==== Putting It All Together

[[_12_8_]]
=== Jagged Arrays

[[_12_8_137_]]
==== Declaring a Jagged Array

[[_12_8_138_]]
==== Shortcut Instantiation

[[_12_8_139_]]
==== Instantiating a Jagged Array

[[_12_8_140_]]
==== Subarrays in Jagged Arrays

[[_12_9_]]
=== Comparing Rectangular and Jagged Arrays

**One-dimensional arrays** have specific instructions in the CIL that allow them to be **optimized** for performance. Rectangular arrays do not have these instructions and are not optimized to the same level.

[[_12_10_]]
=== The foreach Statement

[[_12_10_141_]]
==== The Iteration Variable Is Read-Only

[[_12_10_142_]]
==== The foreach Statement with Multidimensional Arrays

[[_12_10_143_]]
===== Example with a Rectangular Array

[[_12_10_144_]]
===== Example with a Jagged Array

[[_12_11_]]
=== Array Covariance

[[_12_12_]]
=== Useful Inherited Array Members

[[_12_12_145_]]
==== The Clone Method

[[_12_13_]]
=== Comparing Array Types

[[_13_]]
== 13. Delegates

[[_13_1_]]
=== What Is a Delegate?

You can think of a **delegate** as an object that holds one or more methods. Normally, of course, you wouldn't think of "executing" an object, but a delegate is different from a typical object. **You can execute a delegate**, and when you do so, it executes the method or methods that it "holds."

[W] on steroids (stĕr′oid′, stîr′-)

- In a very large, enhanced, or exaggerated form: *"a weapon one observer had called an M16 on steroids" (Stephen Coonts).*
- When something is on steroids, it is more powerful than it could naturally become, because of some trigger. *That gym-trainer is on anabolic steroids.* *The CLK-GTR is a mercedes-Benz on steroids.*

If you're coming from a C++ background, the fastest way for you to understand **delegates** is to think of them as type-safe, object-oriented C++ function pointers `on steroids`.

[[_13_2_]]
=== An Overview of Delegates

You can think of a delegate as an object that contains an ordered list of methods *with the same signature and return type*, as illustrated in Figure 13-2.

[[_13_3_]]
=== Declaring the Delegate Type

[W] The declaration of a delegate type `looks much like` the declaration of a method, `in that` it has both a return type and a signature.

The return type and signature specify the form of the methods that the delegate will accept.

[[_13_4_]]
=== Creating the Delegate Object

[[_13_5_]]
=== Assigning Delegates

The old delegate object will be disposed of by the garbage collector (GC) when it gets around to it.

[[_13_6_]]
=== Combining Delegates

Delegates are immutable

[[_13_7_]]
=== Adding Methods to Delegates

C# provides syntax for making it appear that you can add a method to a delegate, using the += operator

What is actually happening, of course, is that *when the += operator is used, a new delegate is created*, with an invocation list that is the combination of the delegate on the left and the method listed on the right.

You can add a method to a delegate more than once. Each time you add it, it creates a new element in the invocation list.

[[_13_8_]]
=== Removing Methods from a Delegate

If the invocation list is empty, the delegate is null.

[[_13_9_]]
=== Invoking a Delegate

unless one of the parameters is an *output parameter*, which I'll cover shortly.

[[_13_10_]]
=== Delegate Example

The value returned by the last method in the invocation list is the value returned from the delegate invocation.

[[_13_11_]]
=== Invoking Delegates with Return Values

[[_13_12_]]
=== Invoking Delegates with Reference Parameters

[[_13_13_]]
=== Anonymous Methods

[[_13_13_146_]]
==== Using Anonymous Methods

[[_13_13_147_]]
==== Syntax of Anonymous Methods

[[_13_13_148_]]
===== Return Type

[W] The implementation code of the anonymous method must therefore return an int `on all pathways` through the code.

[[_13_13_149_]]
===== Parameters

.but only if both of the following are true:
- The delegate's parameter list does not contain any **out** parameters.
- The anonymous method does not use any parameters.

[[_13_13_150_]]
===== The params Parameters

then the *params keyword* is omitted

[[_13_13_151_]]
==== Scope of Variables and Parameters

[[_13_13_152_]]
===== Outer Variables

captured: An outer variable used in the implementation code of an anonymous method is said to be *captured* by the method.

[[_13_13_153_]]
===== Extension of a Captured Variable’s Lifetime

[[_13_14_]]
=== Lambda Expressions

[W] **pare down** - decrease gradually or bit by bit

- Rather than requiring you to include this redundant information, C# 3.0 introduced lambda expressions, which `pare down` the syntax of anonymous methods. In fact, if lambda expressions had been introduced first, there never would have been anonymous methods.

- The delegate keyword is redundant
- Place the *lambda operator*, **=>**, between the parameter list and the body of the anonymous method
- The lambda operator is read as **"goes to"**.

[W] `There's more, however, that` the compiler can infer, allowing you to simplify the lambda expression further, as shown in the following code.

- explicitly typed
- implicitly typed

If there's only a single implicitly typed parameter, you can `leave off` the parentheses surrounding it, as shown in the assignment to le3.

If the statement block contains *a single return statement*, you can replace the statement block with just the expression that follows the return keyword, as shown in the assignment to le4.

```
MyDel del = delegate(int x) { return x + 1; }; //- Anonymous method
MyDel le4 = x => x + 1; //- Lambda expression
```

- implicitly typed
- neither *ref* nor *out* parameters: if there are, they're explicitly typed
- parentheses: a single parameter implicitly typed
- empty parentheses: if there are no parameters

[[_14_]]
== 14. Events

[[_14_1_]]
=== Publishers and Subscribers

The methods supplied by the subscribers are called **callback methods**, because the publisher calls the subscribers back by executing their methods. They are also called **event handlers**, because they are the code that is called to handle the event.

[W] Event handler: A method that is registered `with the publisher`, `by the subscriber`, and is executed when the publisher raises the event.

[[_14_2_]]
=== Overview of Source Code Components

[[_14_3_]]
=== Declaring an Event

[[_14_3_154_]]
==== An Event Is a Member

[W] ramification (răm′ə-fĭ-kā′shən)

- A development or consequence growing out of and sometimes complicating a problem, plan, or statement: the ramifications of a court decision.

A common error is to think of an event as a type - `which` it's not. Like a method, or a property, an event is a member of a class or a struct, and there are several important `ramifications` to this.

[[_14_4_]]
=== Subscribing to an Event

[[_14_5_]]
=== Raising an Event

[[_14_6_]]
=== Standard Event Usage

[[_14_6_155_]]
==== Passing Data by Extending EventArgs

[[_14_6_156_]]
==== Removing Event Handlers

[[_14_7_]]
=== Event Accessors

[[_15_]]
== 15. Interfaces

[[_15_1_]]
=== What Is an Interface?

[W] But `even if we could get around that hurdle` and somehow pass in an object of type CB, we would still have a problem, because CB's structure is different from that of CA.

[[_15_1_157_]]
==== Example Using the IComparable Interface

[[_15_2_]]
=== Declaring an Interface

[[_15_3_]]
=== Implementing an Interface

[[_15_3_158_]]
==== Example with a Simple Interface

[[_15_4_]]
=== An Interface Is a Reference Type

[[_15_5_]]
=== Using the as Operator with Interfaces

[[_15_6_]]
=== Implementing Multiple Interfaces

[[_15_7_]]
=== Implementing Interfaces with Duplicate Members

[[_15_8_]]
=== References to Multiple Interfaces

[[_15_9_]]
=== An Inherited Member As an Implementation

[[_15_10_]]
=== Explicit Interface Member Implementations

[[_15_10_159_]]
==== Accessing Explicit Interface Member Implementations

[W] ramification (răm′ə-fĭ-kā′shən) 파문, 여파, 영향(어떤 행동・결정에 따라 생기는, 예상 밖의 복잡한 여러 결과・영향들 중 하나)

- *ramification* - a development that complicates a situation; "the court's decision had many unforeseen ramifications"
- =*complication*
- -*development* - a recent event that has some relevance for the present situation; "recent developments in Iraq"; "what a revolting development!"

This restriction has an important `ramification` for inheritance.

[[_15_11_]]
=== Interfaces Can Inherit Interfaces

[W] The interfaces in the list can `themselves` have inherited interfaces.

[[_15_12_]]
=== Example of Different Classes Implementing an Interface

"new Cat()" has the following meaning

    The instantiation of Cat creates Cat(),
        which hierarchically instantiates Animal and LiveBirth as Animal() and LiveBirth() respectively.

    The "()" means a reference to a point in the heap memory.

the syntax of "animalArray[0] = new Cat();" has the following meaning.

    get the 1st reference to Cat(),
        and then further get the 2nd reference to Animal(),
        and finally saves the 2nd reference to Animal() into animalArray[0]

animalArray[0] gets the final reference to Animal() through Dog(),
    and saves the final reference to Animal() in the array.

The syntax of "Animal a = animalArray[0];" has the following meaning.

    annimalArray[0] has a reference to Animal() in Cat()
        which has a reference to ILiveBirth()
        that has a reference to BabyCalled()

[[_16_]]
== 16. Conversions

[[_16_1_]]
=== What Are Conversions?

[[_16_2_]]
=== Implicit Conversions

[[_16_3_]]
=== Explicit Conversions and Casting

[[_16_3_160_]]
==== Casting

[[_16_4_]]
=== Types of Conversions

[[_16_5_]]
=== Numeric Conversions

[[_16_5_161_]]
==== Implicit Numeric Conversions

[[_16_5_162_]]
==== Overflow Checking Context

[[_16_5_163_]]
===== The checked and unchecked Operators

[[_16_5_164_]]
===== The checked and unchecked Statements

[[_16_5_165_]]
==== Explicit Numeric Conversions

[[_16_5_166_]]
===== Integer Type to Integer Type

[[_16_5_167_]]
===== float or double to Integer Type

[[_16_5_168_]]
===== decimal to Integer Type

[[_16_5_169_]]
===== double to float

[[_16_5_170_]]
===== float or double to decimal

[[_16_5_171_]]
===== decimal to float or double

[[_16_6_]]
=== Reference Conversions

As you well know by now, reference objects comprise two parts in memory: **the reference** and **the data**.

- Part of the information held by the reference is the *type of the data it is pointing at*.
- A reference conversion takes a source reference (srcRef) and returns a reference (targetRef) pointing at the same place in the heap but "labels" the reference as a different type.

[[_16_6_172_]]
==== Implicit Reference Conversions

[[_16_6_173_]]
==== Explicit Reference Conversions

[[_16_6_174_]]
==== Valid Explicit Reference Conversions

- Cast is unnecessary; A is the base class of B.
- Allowed because myVAr1 is null.
- This cast is fine because the data is of type B.

[[_16_7_]]
=== Boxing Conversions

All C# types, including the *value types*, are derived from type *object*. *+++<u>Value types</u>+++*, however, are efficient, lightweight types that do not, by default, include their object component in the *heap*.

When the object component is needed, however, you can use **boxing**, which is an implicit conversion that takes a value type value, creates from it a full reference type object in the heap, and returns a reference to the object.

[[_16_7_175_]]
==== Boxing Creates a Copy

[[_16_7_176_]]
==== The Boxing Conversions

[[_16_8_]]
=== Unboxing Conversions

[[_16_8_177_]]
==== The Unboxing Conversions

[[_16_9_]]
=== User-Defined Conversions

[[_16_9_178_]]
==== Constraints on User-Defined Conversions

[[_16_9_179_]]
==== Example of a User-Defined Conversion

[[_16_9_180_]]
==== Evaluating User-Defined Conversions

[[_16_9_181_]]
==== Example of a Multistep User-Defined Conversion

[[_16_10_]]
=== The is Operator

[[_16_11_]]
=== The as Operator

[[_17_]]
== 17. Generics

[[_17_1_]]
=== What Are Generics?

[W] `There are times`, however, when a class would be more useful if you could "distill" or "refactor" out its actions and apply them not just to the data types for which they are coded, but for other types as well. Generics allow you to do `just that`.

[W] This is particularly designed `for cases in which` there are multiple sections of code performing the same instructions, but on different data types.

[[_17_1_182_]]
==== A Stack Example

[[_17_2_]]
=== Generics in C#

[W] `By this point in the text`, you should be very familiar with the concept that a **type** is not an object but a **template** for an object. `In the same way`, +++<u>a **generic type** is not a type but a **template for a type**</u>+++.

C# provides five kinds of generics: *classes, structs, interfaces, delegates, and methods*. Notice that the first four are types, and methods are members.

User-Defined Types: *[A]rray, [C]lass, [D]elegate, [E]num, [I]nterface, [S]truct*

Generic Types: *[C]lass, [D]elegate, [I]nterface, [S]truct*

[[_17_2_183_]]
==== Continuing with the Stack Example

[[_17_3_]]
=== Generic Classes

Regular classes: declaring the class and creating instances of the class

Generic classes: construct actual class types, and then create references and instances

[[_17_4_]]
=== Declaring a Generic Class

type parameters

[W] demarcate (dĭ-mär′kāt′, dē′mär-kāt′)

.demarcate - set, mark, or draw the boundaries of something
- =delimitate, delimit
- <>circumscribe, confine, limit - restrict or confine, "I limit you to two visits to the pub a day"

There is no special keyword that `flags` a generic class declaration. Instead, the presence of the *type parameter list*, `demarcated` with *angle brackets*, distinguishes a generic class declaration from a regular class declaration.

[[_17_5_]]
=== Creating a Constructed Type

[[_17_6_]]
=== Creating Variables and Instances

[[_17_6_184_]]
==== The Stack Example Using Generics

[[_17_6_185_]]
==== Comparing the Generic and Nongeneric Stack

[[_17_7_]]
=== Constraints on Type Parameters

[[_17_7_186_]]
==== Where Clauses

[[_17_7_187_]]
==== Constraint Types and Order

[[_17_8_]]
=== Generic Methods

[[_17_8_188_]]
==== Declaring a Generic Method

[[_17_8_189_]]
==== Invoking a Generic Method

[[_17_8_190_]]
===== Inferring Types

```
int myInt = 5;
MyMethod<int> (myInt);
MyMethod(myInt);
```

[[_17_8_191_]]
==== Example of a Generic Method

[[_17_9_]]
=== Extension Methods with Generic Classes

[[_17_10_]]
=== Generic Structs

[[_17_11_]]
=== Generic Delegates

[[_17_11_192_]]
==== Another Generic Delegate Example

[[_17_12_]]
=== Generic Interfaces

[[_17_12_193_]]
==== An Example Using Generic Interfaces

[[_17_12_194_]]
==== Generic Interface Implementations Must Be Unique

[[_17_13_]]
=== Covariance

There are three types of *variance* - **covariance**, **contravariance**, and **invariance**.

**assignment compatibility**: every variable has a type assigned to it, and you can assign an object of a more derived type to a variable of one of its base types.

**Assignment compatibility** means that you can assign a reference of a more derived type to a variable of a less derived type.

This constant *relation* between the use of a derived type only as an output value and the validity of the constructed delegate is called **covariance**.

[[_17_14_]]
=== Contravariance

This relation, allowing a more derived object where a less derived object is exprected, is called **contravariance**.

[[_17_14_195_]]
==== Covariance and Contravariance in Interfaces

[[_17_14_196_]]
==== More About Variance

[[_18_]]
== 18. Enumerators and Iterators

[[_18_1_]]
=== Enumerators and Enumerable Types

[[_18_1_197_]]
==== Using the foreach Statement

[[_18_2_]]
=== The IEnumerator Interface

[[_18_2_198_]]
==== The IEnumerable Interface

[[_18_2_199_]]
==== Example Using IEnumerable and IEnumerator

[[_18_3_]]
=== The Generic Enumeration Interfaces

[[_18_4_]]
=== Iterators

[[_18_4_200_]]
==== Iterator Blocks

[[_18_4_201_]]
==== Using an Iterator to Create an Enumerator

[[_18_4_202_]]
==== Using an Iterator to Create an Enumerable

[[_18_5_]]
=== Common Iterator Patterns

[[_18_6_]]
=== Producing Multiple Enumerables

[[_18_7_]]
=== Iterators As Properties

[[_18_8_]]
=== Behind the Scenes with Iterators

[[_19_]]
== 19. Introduction to LINQ

[[_19_1_]]
=== What Is LINQ?

[[_19_2_]]
=== LINQ Providers

[[_19_2_203_]]
==== Anonymous Types

[[_19_3_]]
=== Method Syntax and Query Syntax

[[_19_4_]]
=== Query Variables

[[_19_5_]]
=== The Structure of Query Expressions

[[_19_5_204_]]
==== The from Clause

[[_19_5_205_]]
==== The join Clause

[[_19_5_206_]]
==== What Is a Join?

[[_19_5_207_]]
==== The from . . . let . . . where Section in the Query Body

[[_19_5_208_]]
===== The from Clause

[[_19_5_209_]]
===== The let Clause

[[_19_5_210_]]
===== The where Clause

[[_19_5_211_]]
==== The orderby Clause

[[_19_5_212_]]
==== The select . . . group Clause

[[_19_5_213_]]
==== Anonymous Types in Queries

[[_19_5_214_]]
==== The group Clause

[[_19_5_215_]]
==== Query Continuation: The into Clause

[[_19_6_]]
=== The Standard Query Operators

[W] peruse (pə-ro͞oz′)

.To look at carefully or critically:

- =check (out), con, examine, go over, inspect, scrutinize, study, survey, traverse, view.
- =Informal: case.
- Idiom: give a going-over.

You should `peruse` the list and become familiar with these powerful tools that can save you lots of time and effort. Then when you need to use them, you can look up the full documentation online.

[[_19_6_216_]]
==== Signatures of the Standard Query Operators

[W] The standard query operators are methods declared in class *System.Linq.Enumerable*. These methods, however, `aren't just any methods` - they're extension methods that extend generic class IEnumerable<T>.

[[_19_6_217_]]
==== Query Expressions and the Standard Query Operators

[[_19_6_218_]]
==== Delegates As Parameters

[[_19_6_219_]]
==== The LINQ Predefined Delegate Types

[[_19_6_220_]]
==== Example Using a Delegate Parameter

[[_19_6_221_]]
==== Example Using a Lambda Expression Parameter

[[_19_7_]]
=== LINQ to XML

[[_19_7_222_]]
==== Markup Languages

[[_19_7_223_]]
==== XML Basics

[[_19_7_224_]]
==== The XML Classes

[[_19_7_225_]]
===== Creating, Saving, Loading, and Displaying an XML Document

[[_19_7_226_]]
===== Creating an XML Tree

[[_19_7_227_]]
===== Using Values from the XML Tree

[[_19_7_228_]]
===== Adding Nodes and Manipulating XML

[[_19_7_229_]]
==== Working with XML Attributes

[[_19_7_230_]]
==== Other Types of Nodes

[[_19_7_231_]]
===== XComment

[[_19_7_232_]]
===== XDeclaration

[[_19_7_233_]]
===== XProcessingInstruction

[[_19_7_234_]]
==== Using LINQ Queries with LINQ to XML

[[_20_]]
== 20. Introduction to Asynchronous Programming

.[W] asynchronism (ā-sĭng′krə-nĭz′əm), asynchrony (-krə-nē)
* Lack of temporal concurrence; absence of synchronism.
** asynchronism - the relation that exists when things occur at unrelated times; "the stimulus produced a desynchronizing of the brain waves"
** =asynchrony, desynchronisation, desynchronization, desynchronizing
** <>temporal relation - a relation involving time
** !=synchroneity, synchronicity, synchronisation, synchronism, synchronization, synchronizing, synchrony - the relation that exists when things occur at the same time; "the drug produces an increased synchrony of the brain waves"

[[_20_1_]]
=== What Is Asynchrony?

When you start a program, the system creates a new **process** in memory. A **process** is the set of resources that comprise a running program. These include the virtual address space, file handlers, and a host of other things required for the program to run.

Inside the process, the system creates a *kernel object*, called a **thred**, which represents the actual excuting program. (*Thread* is short for **"thread of execution"**.) Once the process is set up, the system starts the thread executing at the first statement in method **Main**.

Other times, however, no new thread id created, but instead, *the execution of the code is reordered* to make better use of the single thread's capacity.

- C# 5.0
- async/await feature
- BackgroundWorker class
- .NET Task Parallel Library

[[_20_1_235_]]
==== A Starting Example

using System.Threading.Tasks;

[[_20_2_]]
=== The Structure of the async/await Feature

- synchronous
- asynchronous

.aync/await feature: three components
- the calling method
- the async method
- the await expression

[[_20_3_]]
=== What Is An async Method?

- method header: async
- await expressions
- three return types: void, Task, Task<T>
- No out, no ref parameters
- lambda expressions, anonymous methods

.async
- before the return type
- signal that the method contains await expressions
- contextual keyword (async can be an identifier)

[W] We can `generalize` this observation `to the following`, which we will `look at in more detail` shortly.

.return types
- Task<T>: read the *Task's Result* property
- Task: check on the *async* method's state
- void: fire and forget

- Task<T> must return a value of type *T*

[[_20_3_236_]]
==== The Flow of Control in an Async Method

In the meantime, the code in the calling method continues on its course, having received the *Task* object back from the *async* method. When it needs the actual result value, it references the *Result* property of the *Task* object. If, by that point, the *async* method has set that property, the calling method retrieves the value and continues on. +++<u>**Otherwise, it halts and waits for the property to be set before continuing on.**</u>+++

.two confusing things
- return type: *await* returns the return type of the *async* method
- return: *async* method just exits without returning to anything

[[_20_3_237_]]
==== The await Expression

[[_20_3_238_]]
==== Cancelling an async Operation

[[_20_3_239_]]
==== Exception Handling and the await Expression

[[_20_3_240_]]
==== Waiting Synchronously for Tasks in the Calling Method

[[_20_3_241_]]
==== Waiting Asynchronously for Tasks in the async Method

[[_20_3_242_]]
==== The Task.Delay Method

[[_20_4_]]
=== Async Operations in GUI Programs

[[_20_4_243_]]
==== Task.Yield

[[_20_5_]]
=== Using an async Lambda Expression

.[W] backlog (băk′lŏg′, -lôg′)
* backlog - an accumulation of jobs not done or materials not processed that are yet to be dealt with (especially unfilled customer orders for products or services)
* <>aggregation, collection, accumulation, assemblage - several things grouped together or considered as a whole

If the handler code for a particular message takes a long time, a message `backlog` builds up in the message queue, and the program becomes unresponsive because none of the messages can be handled until the long-running handler is finished.

.[W] lurch (lûrch)
* lurch - move abruptly; "The ship suddenly lurched to the left"
** =pitch, shift
** <>move - move so as to change position, perform a nontranslational motion; "He moved his hand slightly to the right"

When the programmer clicked the button, nothing appeared to happen at all, and when he tried to move the window around on the screen several seconds after clicking the button, the window was frozen on the screen and wouldn't move - until after the 4 seconds were done, when the window all of a sudden `lurched` to the new position.

[W] When you run the program, you'll find that its behavior matches the preceding description, `which is that` the button isn't disabled and the status label doesn't change, and if you try to move the window, it won't move until the 4 seconds have passed.

[[_20_6_]]
=== A Full GUI Example

[[_20_7_]]
=== The BackgroundWorker Class

[[_20_7_244_]]
==== Example of the BackgroundWorker Class in a WPF Program

[[_20_8_]]
=== Parallel Loops

[W] So, unfortunately, I've had to `settle for` `whetting your appetite` by introducing just two of its very simple constructs that you can learn and use quickly and easily.

[[_20_9_]]
=== Other Asynchronous Programming Patterns

[W] There might still be occasions, however, `where` you'll need to use the older patters for producing asynchronous code.

[W] After learning these older patterns, `you'll have a greater appreciation for` how much simpler life is with the *async/await* feature.

[[_20_10_]]
=== BeginInvoke and EndInvoke

[[_20_10_245_]]
==== The Wait-Until-Done Pattern

[[_20_10_246_]]
==== The AsyncResult Class

[[_20_10_247_]]
==== The Polling Pattern

[[_20_10_248_]]
==== The Callback Pattern

[[_20_10_249_]]
===== The Callback Method

[[_20_10_250_]]
===== Calling EndInvoke Inside the Callback Method

[[_20_11_]]
=== Timers

[[_21_]]
== 21. Namespaces and Assemblies

[[_21_1_]]
=== Referencing Other Assemblies

[[_21_1_251_]]
==== The mscorlib Library

[[_21_2_]]
=== Namespaces

[W] As you can imagine, with your development machine containing assemblies produced by dozens, if not hundreds, of different companies, `there is likely to be` a certain amount of duplication in the names of classes.

[[_21_2_252_]]
==== Namespace Names

[[_21_2_253_]]
==== More About Namespaces

[[_21_2_254_]]
==== Namespaces Spread Across Files

[[_21_2_255_]]
==== Nesting Namespaces

[[_21_3_]]
=== The using Directives

[[_21_3_256_]]
==== The using Namespace Directive

[W] You saw in the MyWidgets example `several sections back` that you can specify a class by using the fully
qualified name.

[[_21_3_257_]]
==== The using Alias Directive

.[W] alias (ā′lē-əs, āl′yəs)
* alias - a name that has been assumed temporarily
** =assumed name, false name
** >name - a language unit by which a person or thing is known; "his name really is George Washington"; "those are two names for the same thing"

[[_21_4_]]
=== The Structure of an Assembly

[[_21_5_]]
=== The Identity of an Assembly

[[_21_6_]]
=== Strongly Named Assemblies

[[_21_6_258_]]
==== Creating a Strongly Named Assembly

[[_21_7_]]
=== Private Deployment of an Assembly

[W] If the application doesn't need other assemblies (such as DLLs) or if the required DLLs are in the same directory, the program should `work just fine where it is`.

[[_21_8_]]
=== Shared Assemblies and the GAC

[[_21_8_259_]]
==== Installing Assemblies into the GAC

[[_21_8_260_]]
==== Side-by-Side Execution in the GAC

[[_21_9_]]
=== Configuration Files

[[_21_10_]]
=== Delayed Signing

[[_22_]]
== 22. Exceptions

[[_22_1_]]
=== What Are Exceptions?

[[_22_2_]]
=== The try Statement

[W] The finally block contains code to be executed `under all circumstances`, whether or not an exception is raised.

[[_22_2_261_]]
==== Handling the Exception

[[_22_3_]]
=== The Exception Classes

[[_22_4_]]
=== The catch Clause

[[_22_5_]]
=== Examples Using Specific catch Clauses

[[_22_6_]]
=== The catch Clauses Section

[[_22_7_]]
=== The finally Block

[[_22_8_]]
=== Finding a Handler for an Exception

[[_22_9_]]
=== Searching Further

[[_22_9_262_]]
==== General Algorithm

[[_22_9_263_]]
==== Example of Searching Down the Call Stack

[[_22_10_]]
=== Throwing Exceptions

[[_22_11_]]
=== Throwing Without an Exception Object

[[_23_]]
== 23. Preprocessor Directives

[[_23_1_]]
=== What Are Preprocessor Directives?

[[_23_2_]]
=== General Rules

[[_23_3_]]
=== The #define and #undef Directives

[[_23_4_]]
=== Conditional Compilation

[[_23_5_]]
=== The Conditional Compilation Constructs

[[_23_6_]]
=== Diagnostic Directives

[[_23_7_]]
=== Line Number Directives

[[_23_8_]]
=== Region Directives

[[_23_9_]]
=== The #pragma warning Directive

[[_24_]]
== 24. Reflection and Attributes

[[_24_1_]]
=== Metadata and Reflection

[[_24_2_]]
=== The Type Class

[[_24_3_]]
=== Getting a Type Object

[[_24_4_]]
=== What Is an Attribute?

[[_24_5_]]
=== Applying an Attribute

[[_24_6_]]
=== Predefined, Reserved Attributes

[[_24_6_264_]]
==== The Obsolete Attribute

[[_24_6_265_]]
==== The Conditional Attribute

[[_24_6_266_]]
===== Example of the Conditional Attribute

[[_24_6_267_]]
==== The Caller Information Attributes

[[_24_6_268_]]
==== The DebuggerStepThrough Attribute

[[_24_6_269_]]
==== Other Predefined Attributes

[[_24_7_]]
=== More About Applying Attributes

[[_24_7_270_]]
==== Multiple Attributes

[[_24_7_271_]]
==== Other Types of Targets

[[_24_7_272_]]
==== Global Attributes

[[_24_8_]]
=== Custom Attributes

[[_24_8_273_]]
==== Declaring a Custom Attribute

[[_24_8_274_]]
==== Using Attribute Constructors

[[_24_8_275_]]
==== Specifying the Constructor

[[_24_8_276_]]
==== Using the Constructor

[[_24_8_277_]]
==== Positional and Named Parameters in Constructors

[[_24_8_278_]]
==== Restricting the Usage of an Attribute

[[_24_8_279_]]
===== The Constructor for AttributeUsage

[[_24_8_280_]]
==== Suggested Practices for Custom Attributes

[[_24_9_]]
=== Accessing an Attribute

[[_24_9_281_]]
==== Using the IsDefined Method

[[_24_9_282_]]
==== Using the GetCustomAttributes Method

[[_25_]]
== 25. Other Topics

[[_25_1_]]
=== Overview

[[_25_2_]]
=== Strings

[[_25_3_]]
=== The StringBuilder Class

[[_25_4_]]
=== Parsing Strings to Data Values

[[_25_5_]]
=== More About the Nullable Types

[[_25_5_283_]]
==== Assigning to a Nullable Type

[[_25_5_284_]]
==== The Null Coalescing Operator

[[_25_5_285_]]
==== Using Nullable User-Defined Types

[[_25_5_286_]]
===== Nullable<T>

[[_25_6_]]
=== Method Main

[[_25_6_287_]]
==== Accessibility of Main

[[_25_7_]]
=== Documentation Comments

[[_25_7_288_]]
==== Inserting Documentation Comments

[[_25_7_289_]]
==== Using Other XML Tags

[[_25_8_]]
=== Nested Types

[[_25_8_290_]]
==== Example of a Nested Class

[[_25_8_291_]]
==== Visibility and Nested Types

[[_25_9_]]
=== Destructors and the Dispose Pattern

[[_25_9_292_]]
==== The Standard Dispose Pattern

[[_25_9_293_]]
==== Comparing Constructors and Destructors

[[_25_10_]]
=== Interoperating with COM
